import { createServer, Agent } from 'https';
import { inspect, promisify, deprecate } from 'util';
import fetch from 'node-fetch';
import createDebug from 'debug';
import { URL, URLSearchParams } from 'url';
import { load } from 'cheerio';
import { CookieJar } from 'tough-cookie';
import { createHash, randomBytes } from 'crypto';
import { createReadStream } from 'fs';
import { Stream, PassThrough, Readable } from 'stream';
import { SandwichStream } from 'sandwich-stream';
import { noopNext, getOptionalMiddleware, compose } from 'middleware-io';
import { createServer as createServer$1 } from 'http';
import WebSocket from 'ws';

var version = "4.0.0-rc.20";

// @ts-ignore
/**
 * Chat peer ID
 */
const CHAT_PEER = 2e9;
/**
 * Blank html redirect
 */
const CALLBACK_BLANK = 'https://oauth.vk.com/blank.html';
/**
 * User-Agent for standalone auth
 */
const DESKTOP_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.80 Safari/537.36';
/**
 * Minimum time interval api with error
 */
const MINIMUM_TIME_INTERVAL_API = 1133;
/**
 * Default options
 */
const defaultOptions = {
    token: null,
    agent: null,
    language: null,
    appId: null,
    appSecret: null,
    login: null,
    phone: null,
    password: null,
    authScope: 'all',
    authTimeout: 10e3,
    apiMode: 'sequential',
    apiWait: 3e3,
    apiLimit: 3,
    apiVersion: '5.101',
    apiBaseUrl: 'https://api.vk.com/method',
    apiAttempts: 3,
    apiTimeout: 10e3,
    apiHeaders: {
        'User-Agent': `vk-io/${version} (+https://github.com/negezor/vk-io)`
    },
    apiExecuteCount: 25,
    apiExecuteMethods: ['messages.send'],
    uploadTimeout: 20e3,
    pollingWait: 3e3,
    pollingAttempts: 3,
    pollingGroupId: null,
    webhookSecret: null,
    webhookConfirmation: null,
    collectAttempts: 3
};
/**
 * The attachment types
 */
var attachmentTypes;
(function (attachmentTypes) {
    attachmentTypes["AUDIO"] = "audio";
    attachmentTypes["AUDIO_MESSAGE"] = "audio_message";
    attachmentTypes["GRAFFITI"] = "graffiti";
    attachmentTypes["DOCUMENT"] = "doc";
    attachmentTypes["GIFT"] = "gift";
    attachmentTypes["LINK"] = "link";
    attachmentTypes["MARKET_ALBUM"] = "market_album";
    attachmentTypes["MARKET"] = "market";
    attachmentTypes["PHOTO"] = "photo";
    attachmentTypes["STICKER"] = "sticker";
    attachmentTypes["VIDEO"] = "video";
    attachmentTypes["WALL_REPLY"] = "wall_reply";
    attachmentTypes["WALL"] = "wall";
    attachmentTypes["POLL"] = "poll";
})(attachmentTypes || (attachmentTypes = {}));
/**
 * Default extensions for attachments
 */
var defaultExtensions;
(function (defaultExtensions) {
    defaultExtensions["photo"] = "jpg";
    defaultExtensions["video"] = "mp4";
    defaultExtensions["audio"] = "mp3";
    defaultExtensions["graffiti"] = "png";
    defaultExtensions["audioMessage"] = "ogg";
})(defaultExtensions || (defaultExtensions = {}));
/**
 * Default content type for attachments
 */
var defaultContentTypes;
(function (defaultContentTypes) {
    defaultContentTypes["photo"] = "image/jpeg";
    defaultContentTypes["video"] = "video/mp4";
    defaultContentTypes["audio"] = "audio/mp3";
    defaultContentTypes["graffiti"] = "image/png";
    defaultContentTypes["audioMessage"] = "audio/ogg";
})(defaultContentTypes || (defaultContentTypes = {}));
/**
 * Sources of captcha
 */
var captchaTypes;
(function (captchaTypes) {
    captchaTypes[captchaTypes["API"] = 0] = "API";
    captchaTypes[captchaTypes["DIRECT_AUTH"] = 1] = "DIRECT_AUTH";
    captchaTypes[captchaTypes["IMPLICIT_FLOW_AUTH"] = 2] = "IMPLICIT_FLOW_AUTH";
    captchaTypes[captchaTypes["ACCOUNT_VERIFICATION"] = 3] = "ACCOUNT_VERIFICATION";
})(captchaTypes || (captchaTypes = {}));
/**
 * Message source
 */
var messageSources;
(function (messageSources) {
    messageSources["USER"] = "user";
    messageSources["CHAT"] = "chat";
    messageSources["GROUP"] = "group";
    messageSources["EMAIL"] = "email";
})(messageSources || (messageSources = {}));
/**
 * Resource types
 */
var resourceTypes;
(function (resourceTypes) {
    resourceTypes["USER"] = "user";
    resourceTypes["GROUP"] = "group";
    resourceTypes["APPLICATION"] = "application";
})(resourceTypes || (resourceTypes = {}));
/**
 * API error codes
 */
var apiErrors;
(function (apiErrors) {
    apiErrors[apiErrors["UNKNOWN_ERROR"] = 1] = "UNKNOWN_ERROR";
    apiErrors[apiErrors["APP_SWITCHED_OFF"] = 2] = "APP_SWITCHED_OFF";
    apiErrors[apiErrors["UNKNOWN_METHOD"] = 3] = "UNKNOWN_METHOD";
    apiErrors[apiErrors["INVALID_SIGNATURE"] = 4] = "INVALID_SIGNATURE";
    apiErrors[apiErrors["AUTH_FAILURE"] = 5] = "AUTH_FAILURE";
    apiErrors[apiErrors["TOO_MANY_REQUESTS"] = 6] = "TOO_MANY_REQUESTS";
    apiErrors[apiErrors["SCOPE_NEEDED"] = 7] = "SCOPE_NEEDED";
    apiErrors[apiErrors["INCORRECT_REQUEST"] = 8] = "INCORRECT_REQUEST";
    apiErrors[apiErrors["TOO_MANY_SIMILAR_ACTIONS"] = 9] = "TOO_MANY_SIMILAR_ACTIONS";
    apiErrors[apiErrors["INTERNAL_ERROR"] = 10] = "INTERNAL_ERROR";
    apiErrors[apiErrors["RESPONSE_SIZE_TOO_BIG"] = 13] = "RESPONSE_SIZE_TOO_BIG";
    apiErrors[apiErrors["CAPTCHA_REQUIRED"] = 14] = "CAPTCHA_REQUIRED";
    apiErrors[apiErrors["ACCESS_DENIED"] = 15] = "ACCESS_DENIED";
    apiErrors[apiErrors["USER_VALIDATION_REQUIRED"] = 17] = "USER_VALIDATION_REQUIRED";
    apiErrors[apiErrors["PAGE_BLOCKED"] = 18] = "PAGE_BLOCKED";
    apiErrors[apiErrors["STANDALONE_ONLY"] = 20] = "STANDALONE_ONLY";
    apiErrors[apiErrors["STANDALONE_AND_OPEN_API_ONLY"] = 21] = "STANDALONE_AND_OPEN_API_ONLY";
    apiErrors[apiErrors["METHOD_DISABLED"] = 23] = "METHOD_DISABLED";
    apiErrors[apiErrors["CONFIRMATION_REQUIRED"] = 24] = "CONFIRMATION_REQUIRED";
    apiErrors[apiErrors["GROUP_TOKEN_NOT_VALID"] = 27] = "GROUP_TOKEN_NOT_VALID";
    apiErrors[apiErrors["APP_TOKEN_NOT_VALID"] = 28] = "APP_TOKEN_NOT_VALID";
    apiErrors[apiErrors["METHOD_CALL_LIMIT"] = 29] = "METHOD_CALL_LIMIT";
    apiErrors[apiErrors["PROFILE_IS_PRIVATE"] = 30] = "PROFILE_IS_PRIVATE";
    apiErrors[apiErrors["WRONG_PARAMETER"] = 100] = "WRONG_PARAMETER";
    apiErrors[apiErrors["INVALID_APPLICATION_ID"] = 101] = "INVALID_APPLICATION_ID";
    apiErrors[apiErrors["LIMIT_ENTRY_EXHAUSTED"] = 103] = "LIMIT_ENTRY_EXHAUSTED";
    apiErrors[apiErrors["INCORRECT_USER_ID"] = 113] = "INCORRECT_USER_ID";
    apiErrors[apiErrors["INVALID_TIMESTAMP"] = 150] = "INVALID_TIMESTAMP";
    apiErrors[apiErrors["ALBUM_ACCESS_DENIED"] = 200] = "ALBUM_ACCESS_DENIED";
    apiErrors[apiErrors["AUDIO_ACCESS_DENIED"] = 201] = "AUDIO_ACCESS_DENIED";
    apiErrors[apiErrors["GROUP_ACCESS_DENIED"] = 203] = "GROUP_ACCESS_DENIED";
    apiErrors[apiErrors["ALBUM_OVERFLOW"] = 300] = "ALBUM_OVERFLOW";
    apiErrors[apiErrors["PAYMENTS_DISABLED"] = 500] = "PAYMENTS_DISABLED";
    apiErrors[apiErrors["COMMERCIAL_ACCESS_DENIED"] = 600] = "COMMERCIAL_ACCESS_DENIED";
    apiErrors[apiErrors["COMMERCIAL_ERROR"] = 603] = "COMMERCIAL_ERROR";
    apiErrors[apiErrors["BLACKLISTED_USER"] = 900] = "BLACKLISTED_USER";
    apiErrors[apiErrors["MESSAGE_COMMUNITY_BLOCKED_BY_USER"] = 901] = "MESSAGE_COMMUNITY_BLOCKED_BY_USER";
    apiErrors[apiErrors["MESSAGE_BLOCKED_BY_USER_PRIVACY"] = 902] = "MESSAGE_BLOCKED_BY_USER_PRIVACY";
    apiErrors[apiErrors["UNABLE_TO_EDIT_MESSAGE_AFTER_DAY"] = 909] = "UNABLE_TO_EDIT_MESSAGE_AFTER_DAY";
    apiErrors[apiErrors["MESSAGE_CANNOT_EDIT_IS_TOO_LONG"] = 910] = "MESSAGE_CANNOT_EDIT_IS_TOO_LONG";
    apiErrors[apiErrors["KEYBOARD_FORMAT_IS_INVALID"] = 911] = "KEYBOARD_FORMAT_IS_INVALID";
    apiErrors[apiErrors["CHAT_BOT_FEATURE"] = 912] = "CHAT_BOT_FEATURE";
    apiErrors[apiErrors["TOO_MANY_FORWARDED_MESSAGES"] = 913] = "TOO_MANY_FORWARDED_MESSAGES";
    apiErrors[apiErrors["MESSAGE_TOO_LONG"] = 914] = "MESSAGE_TOO_LONG";
    apiErrors[apiErrors["NO_ACCESS_TO_CONVERSATION"] = 917] = "NO_ACCESS_TO_CONVERSATION";
    apiErrors[apiErrors["CANNOT_EDIT_THIS_TYPE_MESSAGE"] = 920] = "CANNOT_EDIT_THIS_TYPE_MESSAGE";
    apiErrors[apiErrors["UNABLE_TO_FORWARD_MESSAGES"] = 921] = "UNABLE_TO_FORWARD_MESSAGES";
    apiErrors[apiErrors["UNABLE_TO_DELETE_MESSAGE_FOR_RECIPIENTS"] = 924] = "UNABLE_TO_DELETE_MESSAGE_FOR_RECIPIENTS";
    apiErrors[apiErrors["NOT_ADMIN_CHAT"] = 925] = "NOT_ADMIN_CHAT";
    apiErrors[apiErrors["COMMUNITY_CANNOT_INTERACT_WITH_THIS_PEER"] = 932] = "COMMUNITY_CANNOT_INTERACT_WITH_THIS_PEER";
    apiErrors[apiErrors["CONTACT_NOT_FOUND"] = 936] = "CONTACT_NOT_FOUND";
})(apiErrors || (apiErrors = {}));
/**
 * Auth error codes
 */
var authErrors;
(function (authErrors) {
    authErrors["PAGE_BLOCKED"] = "PAGE_BLOCKED";
    authErrors["INVALID_PHONE_NUMBER"] = "INVALID_PHONE_NUMBER";
    authErrors["AUTHORIZATION_FAILED"] = "AUTHORIZATION_FAILED";
    authErrors["FAILED_PASSED_CAPTCHA"] = "FAILED_PASSED_CAPTCHA";
    authErrors["FAILED_PASSED_TWO_FACTOR"] = "FAILED_PASSED_TWO_FACTOR";
})(authErrors || (authErrors = {}));
/**
 * Upload error codes
 */
var uploadErrors;
(function (uploadErrors) {
    uploadErrors["MISSING_PARAMETERS"] = "MISSING_PARAMETERS";
    uploadErrors["NO_FILES_TO_UPLOAD"] = "NO_FILES_TO_UPLOAD";
    uploadErrors["EXCEEDED_MAX_FILES"] = "EXCEEDED_MAX_FILES";
    uploadErrors["UNSUPPORTED_SOURCE_TYPE"] = "UNSUPPORTED_SOURCE_TYPE";
})(uploadErrors || (uploadErrors = {}));
/**
 * Updates error codes
 */
var updatesErrors;
(function (updatesErrors) {
    updatesErrors["NEED_RESTART"] = "NEED_RESTART";
    updatesErrors["POLLING_REQUEST_FAILED"] = "POLLING_REQUEST_FAILED";
})(updatesErrors || (updatesErrors = {}));
/**
 * Collect error codes
 */
var collectErrors;
(function (collectErrors) {
    collectErrors["EXECUTE_ERROR"] = "EXECUTE_ERROR";
})(collectErrors || (collectErrors = {}));
/**
 * Snippets error codes
 */
var snippetsErrors;
(function (snippetsErrors) {
    snippetsErrors["INVALID_URL"] = "INVALID_URL";
    snippetsErrors["INVALID_RESOURCE"] = "INVALID_RESOURCE";
    snippetsErrors["RESOURCE_NOT_FOUND"] = "RESOURCE_NOT_FOUND";
})(snippetsErrors || (snippetsErrors = {}));
/**
 * Snippets error codes
 */
var sharedErrors;
(function (sharedErrors) {
    sharedErrors["MISSING_CAPTCHA_HANDLER"] = "MISSING_CAPTCHA_HANDLER";
    sharedErrors["MISSING_TWO_FACTOR_HANDLER"] = "MISSING_TWO_FACTOR_HANDLER";
})(sharedErrors || (sharedErrors = {}));
/**
 * Updates sources
 */
var updatesSources;
(function (updatesSources) {
    updatesSources["POLLING"] = "POLLING";
    updatesSources["WEBHOOK"] = "WEBHOOK";
})(updatesSources || (updatesSources = {}));
/**
 * List of user permissions and their bit mask
 */
const userScopes = new Map([
    ['notify', 1],
    ['friends', 2],
    ['photos', 4],
    ['audio', 8],
    ['video', 16],
    ['pages', 128],
    ['link', 256],
    ['status', 1024],
    ['notes', 2048],
    ['messages', 4096],
    ['wall', 8192],
    ['ads', 32768],
    ['offline', 65536],
    ['docs', 131072],
    ['groups', 262144],
    ['notifications', 524288],
    ['stats', 1048576],
    ['email', 4194304],
    ['market', 134217728]
]);
/**
 * List of group permissions and their bit mask
 */
const groupScopes = new Map([
    ['stories', 1],
    ['photos', 4],
    // ['app_widget', 64],
    ['messages', 4096],
    ['docs', 131072],
    ['manage', 262144]
]);
/**
 * VK Platforms
 */
const platforms = new Map([
    [1, 'mobile'],
    [2, 'iphone'],
    [3, 'ipad'],
    [4, 'android'],
    [5, 'wphone'],
    [6, 'windows'],
    [7, 'web'],
    [8, 'standalone']
]);
/**
 * Parse attachments with RegExp
 */
const parseAttachment = /(photo|video|audio|doc|audio_message|graffiti|wall|market|poll|gift)([-\d]+)_(\d+)_?(\w+)?/;
/**
 * Parse resource with RegExp
 */
const parseResource = /(id|club|public|albums|tag|app(?:lication))([-\d]+)/;
/**
 * Parse owner resource with RegExp
 */
const parseOwnerResource = /(album|topic|wall|page|videos)([-\d]+)_(\d+)/;
/**
 * Inspect custom data
 */
const inspectCustomData = Symbol('inspectCustomData');

/**
 * Returns method for execute
 */
const getExecuteMethod = (method, params = {}) => {
    const options = {};
    for (const [key, value] of Object.entries(params)) {
        options[key] = typeof value === 'object'
            ? String(value)
            : value;
    }
    return `API.${method}(${JSON.stringify(options)})`;
};
/**
 * Returns chain for execute
 */
const getChainReturn = (methods) => (`return [${methods.join(',')}];`);
/**
 * Resolve task
 */
const resolveExecuteTask = (tasks, result) => {
    let errors = 0;
    result.response.forEach((response, i) => {
        if (response !== false) {
            tasks[i].resolve(response);
            return;
        }
        tasks[i].reject(result.errors[errors]);
        errors += 1;
    });
};
/**
 * Returns random ID
 */
const getRandomId = () => (`${Math.floor(Math.random() * 1e4)}${Date.now()}`);
/**
 * Delay N-ms
 */
const delay = (delayed) => (new Promise((resolve) => {
    setTimeout(resolve, delayed);
}));
const lt = /&lt;/g;
const qt = /&gt;/g;
const br = /<br>/g;
const amp = /&amp;/g;
const quot = /&quot;/g;
/**
 * Decodes HTML entities
 */
const unescapeHTML = (text) => (text
    .replace(lt, '<')
    .replace(qt, '>')
    .replace(br, '\n')
    .replace(amp, '&')
    .replace(quot, '"'));
/**
 * Copies object params to new object
 */
const copyParams = (params, properties) => {
    // @ts-ignore
    const copies = {};
    for (const property of properties) {
        copies[property] = params[property];
    }
    return copies;
};
/**
 * Returns peer id type
 */
const getPeerType = (id) => {
    if (CHAT_PEER < id) {
        return messageSources.CHAT;
    }
    if (id < 0) {
        return messageSources.GROUP;
    }
    return messageSources.USER;
};
/**
 * Displays deprecated message
 */
const showDeprecatedMessage = (message) => {
    // eslint-disable-next-line no-console
    console.log(' \u001b[31mDeprecated:\u001b[39m', message);
};

class Request {
    /**
     * Constructor
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(method, params = {}) {
        this.attempts = 0;
        this.method = method;
        this.params = { ...params };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Request';
    }
    /**
     * Adds attempt
     */
    addAttempt() {
        this.attempts += 1;
        return this.attempts;
    }
    /**
     * Returns string to execute
     */
    toString() {
        return getExecuteMethod(this.method, this.params);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { method, params, promise } = this;
        const payload = { method, params, promise };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * General error class
 */
class VKError extends Error {
    /**
     * Constructor
     */
    constructor({ code, message }) {
        super(message);
        this.code = code;
        this.message = message;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns property for json
     */
    toJSON() {
        const json = {};
        for (const key of Object.getOwnPropertyNames(this)) {
            json[key] = this[key];
        }
        return json;
    }
}

const { CAPTCHA_REQUIRED, USER_VALIDATION_REQUIRED, CONFIRMATION_REQUIRED } = apiErrors;
class APIError extends VKError {
    /**
     * Constructor
     */
    constructor(payload) {
        const code = Number(payload.error_code);
        const message = `Code №${code} - ${payload.error_msg}`;
        super({ code, message });
        this.params = payload.request_params;
        if (code === CAPTCHA_REQUIRED) {
            this.captchaSid = Number(payload.captcha_sid);
            this.captchaImg = payload.captcha_img;
        }
        else if (code === USER_VALIDATION_REQUIRED) {
            this.redirectUri = payload.redirect_uri;
        }
        else if (code === CONFIRMATION_REQUIRED) {
            this.confirmationText = payload.confirmation_text;
        }
    }
}

const { DEBUG = '' } = process.env;
const isDebug = DEBUG.includes('vk-io:auth');
class AuthError extends VKError {
    /**
     * Constructor
     */
    constructor({ message, code, pageHtml = null }) {
        super({ message, code });
        this.pageHtml = isDebug
            ? pageHtml
            : null;
    }
}

class UploadError extends VKError {
}

class CollectError extends VKError {
    /**
     * Constructor
     */
    constructor({ message, code, errors }) {
        super({ message, code });
        this.errors = errors;
    }
}

class UpdatesError extends VKError {
}

class ExecuteError extends VKError {
    /**
     * Constructor
     */
    constructor(options) {
        const code = Number(options.error_code);
        const message = `Code №${code} - ${options.error_msg}`;
        super({ code, message });
        this.method = options.method;
    }
}

class SnippetsError extends VKError {
}

class StreamingRuleError extends VKError {
    /**
     * Constructor
     */
    constructor({ message, error_code: code }) {
        super({ message, code });
    }
}

/**
 * Returns the entire permission bit mask
 */
const getAllUsersPermissions = () => (Array.from(userScopes.values()).reduce((previous, current) => (previous + current), 0));
/**
 * Returns the entire permission bit mask
 */
const getAllGroupsPermissions = () => (Array.from(groupScopes.values()).reduce((previous, current) => (previous + current), 0));
/**
 * Returns the bit mask of the user permission by name
 */
const getUsersPermissionsByName = (rawScope) => {
    const scope = !Array.isArray(rawScope)
        ? rawScope.split(/,\s{0,}/)
        : rawScope;
    let bitMask = 0;
    for (const name of scope) {
        if (userScopes.has(name)) {
            bitMask += userScopes.get(name);
        }
    }
    return bitMask;
};
/**
 * Returns the bit mask of the group permission by name
 */
const getGroupsPermissionsByName = (rawScope) => {
    const scope = !Array.isArray(rawScope)
        ? rawScope.split(/,\s{0,}/)
        : rawScope;
    let bitMask = 0;
    for (const name of scope) {
        if (groupScopes.has(name)) {
            bitMask += groupScopes.get(name);
        }
    }
    return bitMask;
};
/**
 * Parse form
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const parseFormField = ($) => {
    const $form = $('form[action][method]');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const fields = {};
    for (const { name, value } of $form.serializeArray()) {
        fields[name] = value;
    }
    return {
        action: $form.attr('action'),
        fields
    };
};
/**
 * Returns full URL use Response
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getFullURL = (action, { url }) => {
    if (action.startsWith('https://')) {
        return new URL(action);
    }
    const { protocol, host } = new URL(url);
    return new URL(action, `${protocol}//${host}`);
};

const debug = createDebug('vk-io:util:fetch-cookie');
const REDIRECT_CODES = [303, 301, 302];
const USER_AGENT_RE = /^User-Agent$/i;
const findUserAgent = (headers) => {
    if (!headers) {
        return null;
    }
    const key = Object.keys(headers)
        .find((header) => USER_AGENT_RE.test(header));
    if (!key) {
        return null;
    }
    return headers[key];
};
const fetchCookieDecorator = (jar = new CookieJar()) => {
    const setCookie = promisify(jar.setCookie).bind(jar);
    const getCookieString = promisify(jar.getCookieString).bind(jar);
    return async function fetchCookie(url, options = {}) {
        const previousCookie = await getCookieString(url);
        const { headers = {} } = options;
        if (previousCookie) {
            headers.cookie = previousCookie;
        }
        debug('fetch url %s', url);
        const response = await fetch(url, {
            ...options,
            headers
        });
        const { 'set-cookie': cookies = [] } = response.headers.raw();
        if (cookies.length === 0) {
            return response;
        }
        await Promise.all(cookies.map((cookie) => (setCookie(cookie, response.url))));
        return response;
    };
};
const fetchCookieFollowRedirectsDecorator = (jar) => {
    const fetchCookie = fetchCookieDecorator(jar);
    return async function fetchCookieFollowRedirects(url, options = {}) {
        const response = await fetchCookie(url, {
            ...options,
            redirect: 'manual'
        });
        const isRedirect = REDIRECT_CODES.includes(response.status);
        if (isRedirect && options.redirect !== 'manual' && options.follow !== 0) {
            debug('Redirect to', response.headers.get('location'));
            let follow;
            if (options.follow) {
                follow = options.follow - 1;
            }
            const userAgent = findUserAgent(options.headers);
            const headers = userAgent
                ? { 'User-Agent': userAgent }
                : {};
            const redirectResponse = await fetchCookieFollowRedirects(response.headers.get('location'), {
                method: 'GET',
                body: null,
                headers,
                follow
            });
            return redirectResponse;
        }
        return response;
    };
};

const debug$1 = createDebug('vk-io:auth:account-verification');
const { INVALID_PHONE_NUMBER, AUTHORIZATION_FAILED, FAILED_PASSED_CAPTCHA, FAILED_PASSED_TWO_FACTOR } = authErrors;
/**
 * Two-factor auth check action
 *
 * @type {string}
 */
const ACTION_AUTH_CODE = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */
const ACTION_SECURITY_CODE = 'act=security';
/**
 * Bind a phone to a page
 *
 * @type {string}
 */
const ACTION_VALIDATE = 'act=validate';
/**
 * Bind a phone to a page action
 *
 * @type {string}
 */
const ACTION_CAPTCHA = 'act=captcha';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */
const TWO_FACTOR_ATTEMPTS = 3;
class AccountVerification {
    /**
     * Constructor
     */
    constructor(vk) {
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
        this.vk = vk;
        const { agent, login, phone } = vk.options;
        this.options = {
            login,
            phone,
            agent
        };
        this.jar = new CookieJar();
        this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'AccountVerification';
    }
    /**
     * Executes the HTTP request
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetch(url, options = {}) {
        const { agent } = this.options;
        const { headers = {} } = options;
        return this.fetchCookie(url, {
            ...options,
            agent,
            timeout: this.vk.options.authTimeout,
            compress: false,
            headers: {
                ...headers,
                'User-Agent': DESKTOP_USER_AGENT
            }
        });
    }
    /**
     * Runs authorization
     */
    // eslint-disable-next-line consistent-return, @typescript-eslint/no-explicit-any
    async run(redirectUri) {
        let response = await this.fetch(redirectUri, {
            method: 'GET'
        });
        const isProcessed = true;
        while (isProcessed) {
            const { url } = response;
            if (url.includes(CALLBACK_BLANK)) {
                let { hash } = new URL(response.url);
                if (hash.startsWith('#')) {
                    hash = hash.substring(1);
                }
                const params = new URLSearchParams(hash);
                if (params.has('error')) {
                    throw new AuthError({
                        message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
                        code: AUTHORIZATION_FAILED
                    });
                }
                const user = params.get('user_id');
                return {
                    user: user !== null
                        ? Number(user)
                        : null,
                    token: params.get('access_token')
                };
            }
            const $ = load(await response.text());
            if (url.includes(ACTION_AUTH_CODE)) {
                response = await this.processTwoFactorForm(response, $);
                continue;
            }
            if (url.includes(ACTION_SECURITY_CODE)) {
                response = await this.processSecurityForm(response, $);
                continue;
            }
            if (url.includes(ACTION_VALIDATE)) {
                response = await this.processValidateForm(response, $);
                continue;
            }
            if (url.includes(ACTION_CAPTCHA)) {
                response = await this.processCaptchaForm(response, $);
                continue;
            }
            throw new AuthError({
                message: 'Account verification failed',
                code: AUTHORIZATION_FAILED
            });
        }
    }
    /**
     * Process two-factor form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processTwoFactorForm(response, $) {
        debug$1('process two-factor handle');
        if (this.twoFactorValidate !== null) {
            this.twoFactorValidate.reject(new AuthError({
                message: 'Incorrect two-factor code',
                code: FAILED_PASSED_TWO_FACTOR,
                pageHtml: $.html()
            }));
            this.twoFactorAttempts += 1;
        }
        if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS) {
            throw new AuthError({
                message: 'Failed passed two-factor authentication',
                code: FAILED_PASSED_TWO_FACTOR
            });
        }
        const { action, fields } = parseFormField($);
        const { code, validate } = await this.vk.callbackService.processingTwoFactor({});
        fields.code = code;
        try {
            const url = getFullURL(action, response);
            const newResponse = await this.fetch(url, {
                method: 'POST',
                body: new URLSearchParams(fields)
            });
            return newResponse;
        }
        catch (error) {
            validate.reject(error);
            throw error;
        }
    }
    /**
     * Process security form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processSecurityForm(response, $) {
        debug$1('process security form');
        const { login, phone } = this.options;
        let number;
        if (phone !== null) {
            number = phone;
        }
        else if (login !== null && !login.includes('@')) {
            number = login;
        }
        else {
            throw new AuthError({
                message: 'Missing phone number in the phone or login field',
                code: INVALID_PHONE_NUMBER
            });
        }
        if (typeof number === 'string') {
            number = number.trim().replace(/^(\+|00)/, '');
        }
        number = String(number);
        const $field = $('.field_prefix');
        const prefix = $field.first().text().trim().replace('+', '').length;
        const postfix = $field.last().text().trim().length;
        const { action, fields } = parseFormField($);
        fields.code = number.slice(prefix, number.length - postfix);
        const url = getFullURL(action, response);
        const rewResponse = await this.fetch(url, {
            method: 'POST',
            body: new URLSearchParams(fields)
        });
        if (rewResponse.url.includes(ACTION_SECURITY_CODE)) {
            throw new AuthError({
                message: 'Invalid phone number',
                code: INVALID_PHONE_NUMBER
            });
        }
        return rewResponse;
    }
    /**
     * Process validation form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    processValidateForm(response, $) {
        const href = $('#activation_wrap a').attr('href');
        const url = getFullURL(href, response);
        return this.fetch(url, {
            method: 'GET'
        });
    }
    /**
     * Process captcha form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processCaptchaForm(response, $) {
        if (this.captchaValidate !== null) {
            this.captchaValidate.reject(new AuthError({
                message: 'Incorrect captcha code',
                code: FAILED_PASSED_CAPTCHA
            }));
            this.captchaValidate = null;
            this.captchaAttempts += 1;
        }
        const { action, fields } = parseFormField($);
        const src = $('.captcha_img').attr('src');
        const { key, validate } = await this.vk.callbackService.processingCaptcha({
            type: captchaTypes.ACCOUNT_VERIFICATION,
            sid: fields.captcha_sid,
            src
        });
        this.captchaValidate = validate;
        fields.captcha_key = key;
        const url = getFullURL(action, response);
        url.searchParams.set('utf8', '1');
        const pageResponse = await this.fetch(url, {
            method: 'POST',
            body: new URLSearchParams(fields)
        });
        return pageResponse;
    }
}

function sequential(next) {
    // @ts-ignore
    this.callMethod(this.queue.shift());
    next();
}

async function parallel(next) {
    // @ts-ignore
    const { queue } = this;
    if (queue[0].method.startsWith('execute')) {
        sequential.call(this, next);
        return;
    }
    // Wait next event loop, saves one request or more
    await delay(0);
    // @ts-ignore
    const { apiExecuteCount } = this.vk.options;
    const tasks = [];
    const chain = [];
    for (let i = 0; i < queue.length; i += 1) {
        if (queue[i].method.startsWith('execute')) {
            continue;
        }
        const request = queue.splice(i, 1)[0];
        i -= 1;
        tasks.push(request);
        chain.push(String(request));
        if (tasks.length >= apiExecuteCount) {
            break;
        }
    }
    try {
        const request = new Request('execute', {
            code: getChainReturn(chain)
        });
        // @ts-ignore
        this.callMethod(request);
        next();
        resolveExecuteTask(tasks, await request.promise);
    }
    catch (error) {
        for (const task of tasks) {
            task.reject(error);
        }
    }
}

async function parallelSelected(next) {
    // @ts-ignore
    const { apiExecuteMethods, apiExecuteCount } = this.vk.options;
    // @ts-ignore
    const { queue } = this;
    if (!apiExecuteMethods.includes(queue[0].method)) {
        sequential.call(this, next);
        return;
    }
    // Wait next event loop, saves one request or more
    await delay(0);
    const tasks = [];
    const chain = [];
    for (let i = 0; i < queue.length; i += 1) {
        if (!apiExecuteMethods.includes(queue[i].method)) {
            continue;
        }
        const request = queue.splice(i, 1)[0];
        i -= 1;
        tasks.push(request);
        chain.push(String(request));
        if (tasks.length >= apiExecuteCount) {
            break;
        }
    }
    if (tasks.length === 0) {
        sequential.call(this, next);
        return;
    }
    try {
        const request = new Request('execute', {
            code: getChainReturn(chain)
        });
        // @ts-ignore
        this.callMethod(request);
        next();
        resolveExecuteTask(tasks, await request.promise);
    }
    catch (error) {
        for (const task of tasks) {
            task.reject(error);
        }
    }
}

const { CAPTCHA_REQUIRED: CAPTCHA_REQUIRED$1, TOO_MANY_REQUESTS, USER_VALIDATION_REQUIRED: USER_VALIDATION_REQUIRED$1 } = apiErrors;
const debug$2 = createDebug('vk-io:api');
const requestHandlers = {
    sequential,
    parallel,
    parallel_selected: parallelSelected
};
/**
 * Returns request handler
 */
const getRequestHandler = (mode = 'sequential') => {
    const handler = requestHandlers[mode];
    if (!handler) {
        throw new VKError({
            message: 'Unsuported api mode',
            code: 'UNSUPPORTED_MODE'
        });
    }
    return handler;
};
const groupMethods = [
    'account',
    'ads',
    'appWidgets',
    'apps',
    'audio',
    'auth',
    'board',
    'database',
    'docs',
    'fave',
    'friends',
    'gifts',
    'groups',
    'leads',
    'leadForms',
    'likes',
    'market',
    'messages',
    'newsfeed',
    'notes',
    'notifications',
    'orders',
    'pages',
    'photos',
    'places',
    'polls',
    'podcasts',
    'prettyCards',
    'search',
    'secure',
    'stats',
    'status',
    'storage',
    'stories',
    'streaming',
    'users',
    'utils',
    'video',
    'wall',
    'widgets'
];
/**
 * Working with API methods
 */
class API {
    /**
     * Constructor
     */
    constructor(vk) {
        this.queue = [];
        this.started = false;
        this.suspended = false;
        this.vk = vk;
        for (const group of groupMethods) {
            const isMessagesGroup = group === 'messages';
            /**
             * NOTE: Optimization for other methods
             *
             * Instead of checking everywhere the presence of a property in an object
             * The check is only for the messages group
             * Since it is necessary to change the behavior of the sending method
             */
            this[group] = new Proxy(isMessagesGroup
                ? {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    send: (params = {}) => {
                        const messageParams = params.random_id === undefined
                            ? { ...params, random_id: getRandomId() }
                            : params;
                        return this.enqueue('messages.send', messageParams);
                    }
                }
                : {}, {
                get: isMessagesGroup
                    ? (obj, prop) => obj[prop] || (
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    (params) => (this.enqueue(`${group}.${prop}`, params)))
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    : (obj, prop) => (params) => (this.enqueue(`${group}.${prop}`, params))
            });
        }
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'API';
    }
    /**
     * Returns the current used API version
     */
    get API_VERSION() {
        return this.vk.options.apiVersion;
    }
    /**
     * Call execute method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    execute(params) {
        return this.enqueue('execute', params);
    }
    /**
     * Call execute procedure
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    procedure(name, params) {
        return this.enqueue(`execute.${name}`, params);
    }
    /**
     * Call raw method
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    call(method, params) {
        return this.enqueue(method, params);
    }
    /**
     * Adds request for queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callWithRequest(request) {
        this.queue.push(request);
        this.worker();
        return request.promise;
    }
    /**
     * Adds method to queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    enqueue(method, params) {
        const request = new Request(method, params);
        return this.callWithRequest(request);
    }
    /**
     * Adds an element to the beginning of the queue
     */
    requeue(request) {
        this.queue.unshift(request);
        this.worker();
    }
    /**
     * Running queue
     */
    worker() {
        if (this.started) {
            return;
        }
        this.started = true;
        const { apiLimit, apiMode } = this.vk.options;
        const handler = getRequestHandler(apiMode);
        const interval = Math.round(MINIMUM_TIME_INTERVAL_API / apiLimit);
        const work = () => {
            if (this.queue.length === 0 || this.suspended) {
                this.started = false;
                return;
            }
            handler.call(this, () => {
                setTimeout(work, interval);
            });
        };
        work();
    }
    /**
     * Calls the api method
     */
    async callMethod(request) {
        const { options } = this.vk;
        const { method } = request;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const params = {
            access_token: options.token,
            v: options.apiVersion,
            ...request.params
        };
        if (options.language !== null) {
            params.lang = options.language;
        }
        debug$2(`http --> ${method}`);
        const startTime = Date.now();
        let response;
        try {
            response = await fetch(`${options.apiBaseUrl}/${method}`, {
                method: 'POST',
                compress: false,
                agent: options.agent,
                timeout: options.apiTimeout,
                headers: {
                    ...options.apiHeaders,
                    connection: 'keep-alive'
                },
                body: new URLSearchParams(params)
            });
            response = await response.json();
        }
        catch (error) {
            if (request.addAttempt() <= options.apiAttempts) {
                await delay(options.apiWait);
                debug$2(`Request ${method} restarted ${request.attempts} times`);
                this.requeue(request);
                return;
            }
            if (request.captchaValidate) {
                request.captchaValidate.reject(error);
            }
            request.reject(error);
            return;
        }
        const endTime = (Date.now() - startTime).toLocaleString();
        debug$2(`http <-- ${method} ${endTime}ms`);
        if ('error' in response) {
            this.handleError(request, new APIError(response.error));
            return;
        }
        if (request.captchaValidate) {
            request.captchaValidate.resolve(undefined);
        }
        if (method.startsWith('execute')) {
            request.resolve({
                response: response.response,
                errors: (response.execute_errors || []).map(error => (new ExecuteError(error)))
            });
            return;
        }
        request.resolve(response.response !== undefined
            ? response.response
            : response);
    }
    /**
     * Error API handler
     */
    async handleError(request, error) {
        const { code } = error;
        if (code === TOO_MANY_REQUESTS) {
            if (this.suspended) {
                this.requeue(request);
                return;
            }
            this.suspended = true;
            await delay((MINIMUM_TIME_INTERVAL_API / this.vk.options.apiLimit) + 50);
            this.suspended = false;
            this.requeue(request);
            return;
        }
        if (request.captchaValidate) {
            request.captchaValidate.reject(error);
        }
        if (code === USER_VALIDATION_REQUIRED$1) {
            if (this.suspended) {
                this.requeue(request);
            }
            this.suspended = true;
            try {
                const verification = new AccountVerification(this.vk);
                const { token } = await verification.run(error.redirectUri);
                debug$2('Account verification passed');
                this.vk.token = token;
                this.suspended = false;
                this.requeue(request);
            }
            catch (verificationError) {
                debug$2('Account verification error', verificationError);
                request.reject(error);
                await delay(15e3);
                this.suspended = false;
                this.worker();
            }
            return;
        }
        if (code !== CAPTCHA_REQUIRED$1 || !this.vk.callbackService.hasCaptchaHandler) {
            request.reject(error);
            return;
        }
        try {
            const { captchaSid } = error;
            const { key, validate } = await this.vk.callbackService.processingCaptcha({
                type: captchaTypes.API,
                src: error.captchaImg,
                sid: captchaSid,
                request
            });
            request.captchaValidate = validate;
            request.params.captcha_sid = captchaSid;
            request.params.captcha_key = key;
            this.requeue(request);
        }
        catch (e) {
            request.reject(e);
        }
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { started, queue } = this;
        const payload = { started, queue };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

const debug$3 = createDebug('vk-io:auth:direct');
const { INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$1, AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$1, FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$1, FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$1 } = authErrors;
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */
const TWO_FACTOR_ATTEMPTS$1 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */
const CAPTCHA_ATTEMPTS = 3;
/**
 * Phone number check action
 *
 * @type {string}
 */
const ACTION_SECURITY_CODE$1 = 'act=security';
class DirectAuth {
    /**
     * Constructor
     */
    constructor(vk, options = {}) {
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
        this.vk = vk;
        const { appId = vk.options.appId, appSecret = vk.options.appSecret, login = vk.options.login, phone = vk.options.phone, password = vk.options.password, scope = vk.options.authScope, agent = vk.options.agent, timeout = vk.options.authTimeout, apiVersion = vk.options.apiVersion } = options;
        this.options = {
            appId,
            appSecret,
            login,
            phone,
            password,
            agent,
            scope,
            timeout,
            apiVersion
        };
        this.started = false;
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
    }
    /**
     * Returns custom tag
     *
     * @return {string}
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'DirectAuth';
    }
    /**
     * Executes the HTTP request
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetch(url, options = {}) {
        const { agent, timeout } = this.options;
        const { headers = {} } = options;
        return this.fetchCookie(url, {
            ...options,
            agent,
            timeout,
            compress: false,
            headers: {
                ...headers,
                'User-Agent': DESKTOP_USER_AGENT
            }
        });
    }
    /**
     * Returns permission page
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getPermissionsPage(query = {}) {
        let { scope } = this.options;
        if (scope === 'all' || scope === null) {
            scope = getAllUsersPermissions();
        }
        else if (typeof scope !== 'number') {
            scope = getUsersPermissionsByName(scope);
        }
        debug$3('auth scope %s', scope);
        const { appId, appSecret, login, phone, password, apiVersion } = this.options;
        // @ts-ignore
        const params = new URLSearchParams({
            ...query,
            username: login || phone,
            grant_type: 'password',
            client_secret: appSecret,
            '2fa_supported': this.vk.callbackService.hasTwoFactorHandler
                ? 1
                : 0,
            v: apiVersion,
            client_id: appId,
            password,
            scope
        });
        const url = new URL(`https://oauth.vk.com/token?${params}`);
        return this.fetch(url, {
            method: 'GET'
        });
    }
    /**
     * Runs authorization
     */
    // eslint-disable-next-line consistent-return, @typescript-eslint/no-explicit-any
    async run() {
        if (this.started) {
            throw new AuthError({
                message: 'Authorization already started!',
                code: AUTHORIZATION_FAILED$1
            });
        }
        this.started = true;
        this.fetchCookie = fetchCookieFollowRedirectsDecorator();
        let response = await this.getPermissionsPage();
        let text;
        const isProcessed = true;
        while (isProcessed) {
            text = await response.text();
            let isJSON = true;
            try {
                text = JSON.parse(text);
            }
            catch (e) {
                isJSON = false;
            }
            if (isJSON) {
                if ('access_token' in text) {
                    const { email = null, user_id: user = null, expires_in: expires = null, access_token: token } = text;
                    return {
                        email,
                        user: user !== null
                            ? Number(user)
                            : null,
                        token,
                        expires: expires !== null
                            ? Number(expires)
                            : null
                    };
                }
                if ('error' in text) {
                    if (text.error === 'invalid_client') {
                        throw new AuthError({
                            message: `Invalid client (${text.error_description})`,
                            code: AUTHORIZATION_FAILED$1
                        });
                    }
                    if (text.error === 'need_captcha') {
                        response = await this.processCaptcha(text);
                        continue;
                    }
                    if (text.error === 'need_validation') {
                        if ('validation_type' in text) {
                            response = await this.processTwoFactor(text);
                            continue;
                        }
                        const $ = load(text);
                        response = this.processSecurityForm(response, $);
                        continue;
                    }
                    throw new AuthError({
                        message: 'Unsupported type validation',
                        code: AUTHORIZATION_FAILED$1
                    });
                }
            }
            throw new AuthError({
                message: 'Authorization failed',
                code: AUTHORIZATION_FAILED$1
            });
        }
    }
    /**
     * Process captcha
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processCaptcha({ captcha_sid: sid, captcha_img: src }) {
        debug$3('captcha process');
        if (this.captchaValidate !== null) {
            this.captchaValidate.reject(new AuthError({
                message: 'Incorrect captcha code',
                code: FAILED_PASSED_CAPTCHA$1
            }));
            this.captchaValidate = null;
            this.captchaAttempts += 1;
        }
        if (this.captchaAttempts >= CAPTCHA_ATTEMPTS) {
            throw new AuthError({
                message: 'Maximum attempts passage captcha',
                code: FAILED_PASSED_CAPTCHA$1
            });
        }
        const { key, validate } = await this.vk.callbackService.processingCaptcha({
            type: captchaTypes.DIRECT_AUTH,
            sid,
            src
        });
        this.captchaValidate = validate;
        const response = await this.getPermissionsPage({
            captcha_sid: sid,
            captcha_key: key
        });
        return response;
    }
    /**
     * Process two-factor
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processTwoFactor({ validation_type: validationType, phone_mask: phoneMask }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        debug$3('process two-factor handle');
        if (this.twoFactorValidate !== null) {
            this.twoFactorValidate.reject(new AuthError({
                message: 'Incorrect two-factor code',
                code: FAILED_PASSED_TWO_FACTOR$1
            }));
            this.twoFactorValidate = null;
            this.twoFactorAttempts += 1;
        }
        if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$1) {
            throw new AuthError({
                message: 'Failed passed two-factor authentication',
                code: FAILED_PASSED_TWO_FACTOR$1
            });
        }
        const { code, validate } = await this.vk.callbackService.processingTwoFactor({
            phoneMask,
            type: validationType === '2fa_app'
                ? 'app'
                : 'sms'
        });
        this.twoFactorValidate = validate;
        const response = await this.getPermissionsPage({ code });
        return response;
    }
    /**
     * Process security form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processSecurityForm(response, $) {
        debug$3('process security form');
        const { login, phone } = this.options;
        let number;
        if (phone !== null) {
            number = phone;
        }
        else if (login !== null && !login.includes('@')) {
            number = login;
        }
        else {
            throw new AuthError({
                message: 'Missing phone number in the phone or login field',
                code: INVALID_PHONE_NUMBER$1
            });
        }
        if (typeof number === 'string') {
            number = number.trim().replace(/^(\+|00)/, '');
        }
        number = String(number);
        const $field = $('.field_prefix');
        const prefix = $field.first().text().trim().replace('+', '').length;
        const postfix = $field.last().text().trim().length;
        const { action, fields } = parseFormField($);
        fields.code = number.slice(prefix, number.length - postfix);
        const url = getFullURL(action, response);
        const rewResponse = await this.fetch(url, {
            method: 'POST',
            body: new URLSearchParams(fields)
        });
        if (rewResponse.url.includes(ACTION_SECURITY_CODE$1)) {
            throw new AuthError({
                message: 'Invalid phone number',
                code: INVALID_PHONE_NUMBER$1
            });
        }
        return rewResponse;
    }
}

const debug$4 = createDebug('vk-io:auth:implicit-flow');
const { PAGE_BLOCKED, INVALID_PHONE_NUMBER: INVALID_PHONE_NUMBER$2, AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$2, FAILED_PASSED_CAPTCHA: FAILED_PASSED_CAPTCHA$2, FAILED_PASSED_TWO_FACTOR: FAILED_PASSED_TWO_FACTOR$2 } = authErrors;
/**
 * Blocked action
 *
 * @type {string}
 */
const ACTION_BLOCKED = 'act=blocked';
/**
 * Two-factor auth check action
 *
 * @type {string}
 */
const ACTION_AUTH_CODE$1 = 'act=authcheck';
/**
 * Phone number check action
 *
 * @type {string}
 */
const ACTION_SECURITY_CODE$2 = 'act=security';
/**
 * Number of two-factorial attempts
 *
 * @type {number}
 */
const TWO_FACTOR_ATTEMPTS$2 = 3;
/**
 * Number of captcha attempts
 *
 * @type {number}
 */
const CAPTCHA_ATTEMPTS$1 = 3;
/**
 * Removes the prefix
 *
 * @type {RegExp}
 */
const REPLACE_PREFIX_RE = /^[+|0]+/;
/**
 * Find location.href text
 *
 * @type {RegExp}
 */
const FIND_LOCATION_HREF_RE = /location\.href\s+=\s+"([^"]+)"/i;
class ImplicitFlow {
    /**
     * Constructor
     */
    constructor(vk, options = {}) {
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
        this.vk = vk;
        const { appId = vk.options.appId, appSecret = vk.options.appSecret, login = vk.options.login, phone = vk.options.phone, password = vk.options.password, scope = vk.options.authScope, agent = vk.options.agent, timeout = vk.options.authTimeout, apiVersion = vk.options.apiVersion } = options;
        this.options = {
            appId,
            appSecret,
            login,
            phone,
            password,
            agent,
            scope,
            timeout,
            apiVersion
        };
        this.jar = new CookieJar();
        this.started = false;
        this.captchaValidate = null;
        this.captchaAttempts = 0;
        this.twoFactorValidate = null;
        this.twoFactorAttempts = 0;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns CookieJar
     */
    get cookieJar() {
        return this.jar;
    }
    /**
     * Sets the CookieJar
     */
    set cookieJar(jar) {
        this.jar = jar;
    }
    /**
     * Returns cookie
     */
    async getCookies() {
        const { jar } = this;
        const getCookieString = promisify(jar.getCookieString).bind(jar);
        const [login, main] = await Promise.all([
            getCookieString('https://login.vk.com'),
            getCookieString('https://vk.com')
        ]);
        return {
            'login.vk.com': login,
            'vk.com': main
        };
    }
    /**
     * Executes the HTTP request
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    fetch(url, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    options = {}
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        const { agent, timeout } = this.options;
        const { headers = {} } = options;
        return this.fetchCookie(url, {
            ...options,
            agent,
            timeout,
            compress: false,
            headers: {
                ...headers,
                'User-Agent': DESKTOP_USER_AGENT
            }
        });
    }
    /**
     * Runs authorization
     */
    // eslint-disable-next-line consistent-return, @typescript-eslint/no-explicit-any
    async run() {
        if (this.started) {
            throw new AuthError({
                message: 'Authorization already started!',
                code: AUTHORIZATION_FAILED$2
            });
        }
        this.started = true;
        this.fetchCookie = fetchCookieFollowRedirectsDecorator(this.jar);
        debug$4('get permissions page');
        // @ts-ignore
        let response = await this.getPermissionsPage();
        const isProcessed = true;
        while (isProcessed) {
            const { url } = response;
            debug$4('URL', url);
            if (url.includes(CALLBACK_BLANK)) {
                return { response };
            }
            if (url.includes(ACTION_BLOCKED)) {
                debug$4('page blocked');
                throw new AuthError({
                    message: 'Page blocked',
                    code: PAGE_BLOCKED
                });
            }
            const $ = load(await response.text());
            if (url.includes(ACTION_AUTH_CODE$1)) {
                response = await this.processTwoFactorForm(response, $);
                continue;
            }
            if (url.includes(ACTION_SECURITY_CODE$2)) {
                response = await this.processSecurityForm(response, $);
                continue;
            }
            const $error = $('.box_error');
            const $service = $('.service_msg_warning');
            const isError = $error.length !== 0;
            if (this.captchaValidate === null && (isError || $service.length !== 0)) {
                const errorText = isError
                    ? $error.text()
                    : $service.text();
                throw new AuthError({
                    message: `Auth form error: ${errorText}`,
                    code: AUTHORIZATION_FAILED$2,
                    pageHtml: $.html()
                });
            }
            if ($('input[name="pass"]').length !== 0) {
                response = await this.processAuthForm(response, $);
                continue;
            }
            if (url.includes('act=')) {
                throw new AuthError({
                    message: 'Unsupported authorization event',
                    code: AUTHORIZATION_FAILED$2,
                    pageHtml: $.html()
                });
            }
            debug$4('auth with login & pass complete');
            if ($('form').length !== 0) {
                const { action } = parseFormField($);
                debug$4('url grant access', action);
                response = await this.fetch(action, {
                    method: 'POST'
                });
            }
            else {
                const locations = $.html().match(FIND_LOCATION_HREF_RE);
                if (locations === null) {
                    throw new AuthError({
                        message: 'Could not log in',
                        code: AUTHORIZATION_FAILED$2,
                        pageHtml: $.html()
                    });
                }
                const location = locations[1].replace('&cancel=1', '');
                debug$4('url grant access', location);
                response = await this.fetch(location, {
                    method: 'POST'
                });
            }
        }
    }
    /**
     * Process form auth
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processAuthForm(response, $) {
        debug$4('process login handle');
        if (this.captchaValidate !== null) {
            this.captchaValidate.reject(new AuthError({
                message: 'Incorrect captcha code',
                code: FAILED_PASSED_CAPTCHA$2,
                pageHtml: $.html()
            }));
            this.captchaValidate = null;
            this.captchaAttempts += 1;
        }
        if (this.captchaAttempts > CAPTCHA_ATTEMPTS$1) {
            throw new AuthError({
                message: 'Maximum attempts passage captcha',
                code: FAILED_PASSED_CAPTCHA$2
            });
        }
        const { login, password, phone } = this.options;
        const { action, fields } = parseFormField($);
        fields.email = login || phone;
        fields.pass = password;
        if ('captcha_sid' in fields) {
            const src = $('.oauth_captcha').attr('src') || $('#captcha').attr('src');
            const { key, validate } = await this.vk.callbackService.processingCaptcha({
                type: captchaTypes.IMPLICIT_FLOW_AUTH,
                sid: fields.captcha_sid,
                src
            });
            this.captchaValidate = validate;
            fields.captcha_key = key;
        }
        debug$4('Fields', fields);
        const url = new URL(action);
        url.searchParams.set('utf8', '1');
        const pageResponse = await this.fetch(url, {
            method: 'POST',
            body: new URLSearchParams(fields)
        });
        return pageResponse;
    }
    /**
     * Process two-factor form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processTwoFactorForm(response, $) {
        debug$4('process two-factor handle');
        if (this.twoFactorValidate !== null) {
            this.twoFactorValidate.reject(new AuthError({
                message: 'Incorrect two-factor code',
                code: FAILED_PASSED_TWO_FACTOR$2,
                pageHtml: $.html()
            }));
            this.twoFactorAttempts += 1;
        }
        if (this.twoFactorAttempts >= TWO_FACTOR_ATTEMPTS$2) {
            throw new AuthError({
                message: 'Failed passed two-factor authentication',
                code: FAILED_PASSED_TWO_FACTOR$2
            });
        }
        const { action, fields } = parseFormField($);
        const { code, validate } = await this.vk.callbackService.processingTwoFactor({});
        fields.code = code;
        try {
            const url = getFullURL(action, response);
            const newResponse = await this.fetch(url, {
                method: 'POST',
                body: new URLSearchParams(fields)
            });
            return newResponse;
        }
        catch (error) {
            validate.reject(error);
            throw error;
        }
    }
    /**
     * Process security form
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async processSecurityForm(response, $) {
        debug$4('process security form');
        const { login, phone } = this.options;
        let number;
        if (phone !== null) {
            number = phone;
        }
        else if (login !== null && !login.includes('@')) {
            number = login;
        }
        else {
            throw new AuthError({
                message: 'Missing phone number in the phone or login field',
                code: INVALID_PHONE_NUMBER$2,
                pageHtml: $.html()
            });
        }
        number = String(number).trim().replace(REPLACE_PREFIX_RE, '');
        const $field = $('.field_prefix');
        const { length: prefix } = $field.first().text().trim().replace(REPLACE_PREFIX_RE, '');
        const { length: postfix } = $field.last().text().trim();
        const { action, fields } = parseFormField($);
        fields.code = number.slice(prefix, number.length - postfix);
        const url = getFullURL(action, response);
        const newResponse = await this.fetch(url, {
            method: 'POST',
            body: new URLSearchParams(fields)
        });
        if (newResponse.url.includes(ACTION_SECURITY_CODE$2)) {
            throw new AuthError({
                message: 'Invalid phone number',
                code: INVALID_PHONE_NUMBER$2,
                pageHtml: $.html()
            });
        }
        return newResponse;
    }
}

const debug$5 = createDebug('vk-io:auth:implicit-flow-user');
const { AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$3 } = authErrors;
class ImplicitFlowUser extends ImplicitFlow {
    /**
     * Returns permission page
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getPermissionsPage() {
        const { appId } = this.options;
        let { scope } = this.options;
        if (scope === 'all' || scope === null) {
            scope = getAllUsersPermissions();
        }
        else if (typeof scope !== 'number') {
            scope = getUsersPermissionsByName(scope);
        }
        debug$5('auth scope %s', scope);
        // @ts-ignore
        const params = new URLSearchParams({
            redirect_uri: CALLBACK_BLANK,
            response_type: 'token',
            display: 'page',
            v: this.options.apiVersion,
            client_id: appId,
            scope
        });
        const url = new URL(`https://oauth.vk.com/authorize?${params}`);
        return this.fetch(url, {
            method: 'GET'
        });
    }
    /**
     * Starts authorization
     */
    // @ts-ignore
    async run() {
        const { response } = await super.run();
        let { hash } = new URL(response.url);
        if (hash.startsWith('#')) {
            hash = hash.substring(1);
        }
        const params = new URLSearchParams(hash);
        if (params.has('error')) {
            throw new AuthError({
                message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
                code: AUTHORIZATION_FAILED$3
            });
        }
        const user = params.get('user_id');
        const expires = params.get('expires_in');
        return {
            email: params.get('email'),
            user: user !== null
                ? Number(user)
                : null,
            token: params.get('access_token'),
            expires: expires !== null
                ? Number(expires)
                : null
        };
    }
}

const debug$6 = createDebug('vk-io:auth:implicit-flow-user');
const { AUTHORIZATION_FAILED: AUTHORIZATION_FAILED$4 } = authErrors;
class ImplicitFlowGroups extends ImplicitFlow {
    /**
     * Constructor
     */
    constructor(vk, options) {
        super(vk, options);
        let { groups = null } = options;
        if (groups === null) {
            throw new VKError({
                message: 'Groups list must have',
                code: 'GROUPS_NOT_SET'
            });
        }
        if (!Array.isArray(groups)) {
            groups = [groups];
        }
        this.groups = groups.map((rawGroup) => {
            const group = Number(rawGroup);
            return group < 0
                ? -group
                : group;
        });
    }
    /**
     * Returns permission page
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getPermissionsPage() {
        const { appId } = this.options;
        let { scope } = this.options;
        if (scope === 'all' || scope === null) {
            scope = getAllGroupsPermissions();
        }
        else if (typeof scope !== 'number') {
            scope = getGroupsPermissionsByName(scope);
        }
        debug$6('auth scope %s', scope);
        // @ts-ignore
        const params = new URLSearchParams({
            group_ids: this.groups.join(','),
            redirect_uri: CALLBACK_BLANK,
            response_type: 'token',
            display: 'page',
            v: this.options.apiVersion,
            client_id: appId,
            scope
        });
        const url = new URL(`https://oauth.vk.com/authorize?${params}`);
        return this.fetch(url, {
            method: 'GET'
        });
    }
    /**
     * Starts authorization
     */
    // @ts-ignore
    async run() {
        const { response } = await super.run();
        let { hash } = new URL(response.url);
        if (hash.startsWith('#')) {
            hash = hash.substring(1);
        }
        const params = new URLSearchParams(hash);
        if (params.has('error')) {
            throw new AuthError({
                message: `Failed passed grant access: ${params.get('error_description') || 'Unknown error'}`,
                code: AUTHORIZATION_FAILED$4
            });
        }
        let expires = params.get('expires_in');
        if (expires !== null) {
            expires = Number(expires);
        }
        const tokens = [];
        for (const [name, value] of params) {
            if (!name.startsWith('access_token_')) {
                continue;
            }
            /* Example group access_token_XXXXX */
            const { 2: group } = name.split('_');
            tokens.push({
                group: Number(group),
                token: value,
                expires
            });
        }
        return tokens;
    }
}

const openAPIParams = [
    'expire',
    'secret',
    'mid',
    'sid',
    'sig'
];
class Auth {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Auth';
    }
    /**
     * Standalone authorization with login & password
     */
    implicitFlowUser(options = {}) {
        return new ImplicitFlowUser(this.vk, options);
    }
    /**
     * Standalone authorization with login & password for group
     *
     * @param {*}  groups
     * @param {Object} options
     */
    implicitFlowGroups(groups, options = {}) {
        return new ImplicitFlowGroups(this.vk, { ...options, groups });
    }
    /**
     * Direct authorization with login & login in user application
     */
    direct() {
        const { appId, appSecret } = this.vk.options;
        return new DirectAuth(this.vk, { appId, appSecret });
    }
    /**
     * Direct authorization with login & login in android application
     */
    androidApp() {
        return new DirectAuth(this.vk, {
            appId: 2274003,
            appSecret: 'hHbZxrka2uZ6jB1inYsH'
        });
    }
    /**
     * Direct authorization with login & login in windows application
     */
    windowsApp() {
        return new DirectAuth(this.vk, {
            appId: 3697615,
            appSecret: 'AlVXZFMUqyrnABp8ncuU'
        });
    }
    /**
     * Direct authorization with login & login in windows phone application
     */
    windowsPhoneApp() {
        return new DirectAuth(this.vk, {
            appId: 3502557,
            appSecret: 'PEObAuQi6KloPM4T30DV'
        });
    }
    /**
     * Direct authorization with login & login in iphone application
     */
    iphoneApp() {
        return new DirectAuth(this.vk, {
            appId: 3140623,
            appSecret: 'VeWdmVclDCtn6ihuP1nt'
        });
    }
    /**
     * Direct authorization with login & login in ipad application
     */
    ipadApp() {
        return new DirectAuth(this.vk, {
            appId: 3682744,
            appSecret: 'mY6CDUswIVdJLCD3j15n'
        });
    }
    /**
     * Verifies that the user is authorized through the Open API
     */
    async userAuthorizedThroughOpenAPI(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    params) {
        const paramsKeys = Object.keys(params)
            .filter(key => openAPIParams.includes(key))
            .sort();
        let sign = '';
        for (const key of paramsKeys) {
            if (key !== 'sig') {
                sign += `${key}=${params[key]}`;
            }
        }
        sign += this.vk.options.appSecret;
        sign = createHash('md5')
            .update(sign)
            .digest('hex');
        const isNotExpire = params.expire > (Date.now() / 1000);
        const authorized = params.sig === sign && isNotExpire;
        return { authorized };
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        return `${options.stylize(name, 'special')} {}`;
    }
}

/**
 * Check object is stream
 */
const isStream = (source) => (typeof source === 'object' && source instanceof Stream);
/**
 * Copies object params to new object
 */
const copyParams$1 = (params, properties) => {
    // @ts-ignore
    const copies = {};
    for (const property of properties) {
        if (property in params) {
            copies[property] = params[property];
        }
    }
    return copies;
};
/**
 * Returns buffer from stream in Promise
 */
const streamToBuffer = (stream) => (new Promise((resolve, reject) => {
    const accum = [];
    stream.on('error', reject);
    stream.on('end', () => {
        resolve(Buffer.concat(accum));
    });
    stream.on('data', (chunk) => {
        accum.push(chunk);
    });
}));

const CRNL = '\r\n';
class MultipartStream extends SandwichStream {
    /**
     * Constructor
     */
    constructor(boundary) {
        super({
            head: `--${boundary}${CRNL}`,
            tail: `${CRNL}--${boundary}--`,
            separator: `${CRNL}--${boundary}${CRNL}`
        });
        this.boundary = boundary;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'MultipartStream';
    }
    /**
     * Adds part
     */
    addPart(part) {
        const partStream = new PassThrough();
        if ('headers' in part) {
            for (const [key, header] of Object.entries(part.headers)) {
                partStream.write(`${key}:${header}${CRNL}`);
            }
        }
        partStream.write(CRNL);
        if (isStream(part.body)) {
            part.body.pipe(partStream);
        }
        else {
            partStream.end(part.body);
        }
        this.add(partStream);
    }
    /**
     * Adds form data
     */
    append(field, body, { filename = null, headers = {} }) {
        let header = `form-data; name="${field}"`;
        if (filename !== null) {
            header += `; filename="${filename}"`;
        }
        this.addPart({
            headers: {
                ...headers,
                'Content-Disposition': header
            },
            body
        });
    }
}

class Attachment {
    /**
     * Constructor
     */
    constructor(type, ownerId, id, accessKey = null) {
        this.type = type;
        this.ownerId = Number(ownerId);
        this.id = Number(id);
        this.accessKey = accessKey;
        this.$filled = false;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Parse attachment with string
     */
    static fromString(attachment) {
        if (!parseAttachment.test(attachment)) {
            throw new TypeError('Incorrect attachment');
        }
        const [, type, ownerId, id, accessKey] = attachment.match(parseAttachment);
        return new Attachment(type, ownerId, id, accessKey);
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return true;
    }
    /**
     * Checks that the attachment is equivalent with object
     */
    equals(attachment) {
        const target = typeof attachment === 'string'
            ? Attachment.fromString(attachment)
            : attachment;
        return (this.type === target.type
            && this.ownerId === target.ownerId
            && this.id === target.id);
    }
    /**
     * Returns a string to attach a VK
     */
    toString() {
        const accessKey = this.accessKey !== null
            ? `_${this.accessKey}`
            : '';
        return `${this.type}${this.ownerId}_${this.id}${accessKey}`;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return this[inspectCustomData]();
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return {
            payload: this.payload
        };
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const customData = {
            id: this.id,
            ownerId: this.ownerId,
            accessKey: this.accessKey,
            ...this[inspectCustomData]()
        };
        const payload = this.$filled
            ? `${inspect(customData, { ...options, compact: false })}`
            : '{}';
        return `${options.stylize(name, 'special')} <${options.stylize(this, 'string')}> ${payload}`;
    }
}

class ExternalAttachment {
    /**
     * Constructor
     */
    constructor(type, payload) {
        this.type = type;
        this.payload = payload;
        this.$filled = false;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Returns whether the attachment is filled
     */
    get isFilled() {
        return this.$filled;
    }
    /**
     * Can be attached via string representation
     */
    // eslint-disable-next-line class-methods-use-this
    get canBeAttached() {
        return false;
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return this[inspectCustomData]();
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return this.payload;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const customData = this[inspectCustomData]();
        const payload = inspect(customData, { ...options, compact: false });
        return `${options.stylize(name, 'special')} ${payload}`;
    }
}

const { POLL } = attachmentTypes;
class PollAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(POLL, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'answers' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [poll] = await this.vk.api.polls.getById({
            poll_id: this.id,
            owner_id: this.ownerId
        });
        this.payload = poll;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether the poll is anonymous
     */
    get isAnonymous() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.anonymous);
    }
    /**
     * Checks whether the poll allows multiple choice of answers
     */
    get isMultiple() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.multiple);
    }
    /**
     * Checks whether the poll is complete
     */
    get isClosed() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.closed);
    }
    /**
     * Check whether questions are attached to the discussion
     */
    get isBoard() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_board);
    }
    /**
     * Check if can edit the poll
     */
    get isCanEdit() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Check if can vote in the survey
     */
    get isCanVote() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_vote);
    }
    /**
     * Check if can complain about the poll
     */
    get isCanReport() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_report);
    }
    /**
     * Check if can share a survey
     */
    get isCanShare() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_share);
    }
    /**
     * Returns the ID of the poll author
     */
    get authorId() {
        return this.payload.author_id || null;
    }
    /**
     * Returns the question text
     */
    get question() {
        return this.payload.question || null;
    }
    /**
     * Returns the date when this poll was created
     */
    get createdAt() {
        return this.payload.created || null;
    }
    /**
     * Returns the end date of the poll in Unixtime. 0, if the poll is unlimited
     */
    get endedAt() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.end_date;
    }
    /**
     * Returns the number of votes
     */
    get votes() {
        return this.payload.votes || null;
    }
    /**
     * Returns the identifiers of the response options selected by the current user
     */
    get answerIds() {
        return this.payload.answer_ids || null;
    }
    /**
     * Returns the identifiers of 3 friends who voted in the poll
     */
    get friends() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.friends || [];
    }
    /**
     * Returns the information about the options for the answer
     */
    get answers() {
        return this.payload.answers || null;
    }
    /**
     * Returns the poll snippet background
     */
    get background() {
        return this.payload.background || null;
    }
    /**
     * Returns a photo - the poll snippet background
     */
    get photo() {
        return this.payload.photo || null;
    }
    /**
     * Returns the custom data
     *
     * @type {Object}
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'authorId',
            'question',
            'createdAt',
            'endedAt',
            'votes',
            'answerIds',
            'friends',
            'answers',
            'background',
            'photo'
        ]);
    }
}

const { GIFT } = attachmentTypes;
class GiftAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(GIFT, payload);
        this.vk = vk;
    }
    /**
     * Returns the identifier gift
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return {
            id: this.id
        };
    }
}

// eslint-disable-next-line import/no-cycle
const attachmentsTypes = {
    [attachmentTypes.POLL]: () => PollAttachment,
    [attachmentTypes.GIFT]: () => GiftAttachment,
    [attachmentTypes.WALL]: () => WallAttachment,
    [attachmentTypes.LINK]: () => LinkAttachment,
    [attachmentTypes.PHOTO]: () => PhotoAttachment,
    [attachmentTypes.AUDIO]: () => AudioAttachment,
    [attachmentTypes.VIDEO]: () => VideoAttachment,
    [attachmentTypes.DOCUMENT]: () => DocumentAttachment,
    [attachmentTypes.MARKET]: () => MarketAttachment,
    [attachmentTypes.STICKER]: () => StickerAttachment,
    [attachmentTypes.GRAFFITI]: () => GraffitiAttachment,
    [attachmentTypes.WALL_REPLY]: () => WallReplyAttachment,
    [attachmentTypes.MARKET_ALBUM]: () => MarketAlbumAttachment,
    [attachmentTypes.AUDIO_MESSAGE]: () => AudioMessageAttachment
};
/**
 * Transform raw attachments to wrapper
 */
// @ts-ignore
// eslint-disable-next-line import/prefer-default-export, @typescript-eslint/no-explicit-any
const transformAttachments = (attachments = [], vk) => (attachments
    .map((item) => {
    const { type } = item;
    const attachment = attachmentsTypes[type];
    return attachment
        ? new (attachment())(item[type], vk)
        : false;
})
    .filter(Boolean));

const { WALL } = attachmentTypes;
const kAttachments = Symbol('attachments');
const kCopyHistoryAttachments = Symbol('copyHistoryAttachments');
class WallAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(WALL, payload.owner_id || payload.to_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [post] = await this.vk.api.wall.getById({
            posts: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = post;
        this[kAttachments] = null;
        this[kCopyHistoryAttachments] = null;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks has comments
     */
    get hasComments() {
        if (!this.$filled) {
            return null;
        }
        const { commentsCount } = this;
        return commentsCount !== null
            ? commentsCount > 0
            : null;
    }
    /**
     * Checks has ads in post
     */
    get hasAds() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.marked_as_ads);
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some((attachment) => (attachment.type === type));
    }
    /**
     * Checks has this user reposted
     */
    get hasUserReposted() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.reposts.user_reposted);
    }
    /**
     * Checks has this user likes
     */
    get hasUserLike() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.user_likes);
    }
    /**
     * Checks can the current user comment on the entry
     */
    get isCanUserCommented() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_post);
    }
    /**
     * Checks if a community can comment on a post
     */
    get isCanGroupsCommented() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.groups_can_post);
    }
    /**
     * Checks if you can comment on a post
     */
    get isCanCommented() {
        return this.isCanUserCommented || this.isCanGroupsCommented;
    }
    /**
     * Checks if a user can close on a comments
     */
    get isCanCloseComments() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_close);
    }
    /**
     * Checks if a user can open on a comments
     */
    get isCanOpenComments() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.comments.can_open);
    }
    /**
     * Checks whether the current user can like the record
     */
    get isCanLike() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.can_like);
    }
    /**
     * hecks whether the current user can repost the record
     */
    get isCanReposted() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.likes.can_publish);
    }
    /**
     * Checks is can this user pin post
     */
    get isCanPin() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_pin);
    }
    /**
     * Checks is can this user delete post
     */
    get isCanDelete() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_delete);
    }
    /**
     * Checks is can this user edit post
     */
    get isCanEdit() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.can_edit);
    }
    /**
     * Checks is can this user edit post
     */
    get isPinned() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_pinned);
    }
    /**
     * Checks is post created only by friends
     */
    get isFriendsOnly() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.friends_only);
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Returns the identifier author
     */
    get authorId() {
        return this.payload.from_id || null;
    }
    /**
     * Returns the administrator identifier that posted the entry
     */
    get createdUserId() {
        return this.payload.created_by || null;
    }
    /**
     * The identifier of the record owner, in response to which the current
     */
    get replyOwnerId() {
        return this.payload.reply_owner_id || null;
    }
    /**
     * The identifier of the record in response to which the current one was left.
     */
    get replyPostId() {
        return this.payload.reply_post_id || null;
    }
    /**
     * Returns author identifier if the entry was published
     * on behalf of the community and signed by the user
     */
    get signerId() {
        return this.payload.signer_id || null;
    }
    /**
     * Returns the date when this post was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the post type
     */
    get postType() {
        return this.payload.post_type || null;
    }
    /**
     * Returns the post text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the number of record views
     */
    get viewsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'views' in this.payload
            ? this.payload.views.count
            : null;
    }
    /**
     * Returns the likes count
     */
    get likesCount() {
        if (!this.$filled) {
            return null;
        }
        return 'likes' in this.payload
            ? this.payload.likes.count
            : null;
    }
    /**
     * Returns the reposts count
     */
    get repostsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'reposts' in this.payload
            ? this.payload.reposts.count
            : null;
    }
    /**
     * Returns the comments count
     */
    get commentsCount() {
        if (!this.$filled) {
            return null;
        }
        return 'comments' in this.payload
            ? this.payload.comments.count
            : null;
    }
    /**
     * Returns the likes info
     */
    get likes() {
        return this.payload.likes || null;
    }
    /**
     * Returns the post source
     */
    get postSource() {
        return this.payload.post_source || null;
    }
    /**
     * Returns the geo location
     */
    get geo() {
        return this.payload.geo || null;
    }
    /**
     * Returns the history of reposts for post
     */
    get copyHistory() {
        if (!this[kCopyHistoryAttachments]) {
            this[kCopyHistoryAttachments] = this.payload.copy_history
                ? this.payload.copy_history.map((history) => (new WallAttachment(history, this.vk)))
                : [];
        }
        return this[kCopyHistoryAttachments];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments]) {
            this[kAttachments] = transformAttachments(this.payload.attachments || [], this.vk);
        }
        return this[kAttachments];
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter((attachment) => (attachment.type === type));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'authorId',
            'createdUserId',
            'replyOwnerId',
            'replyPostId',
            'signerId',
            'createdAt',
            'postType',
            'text',
            'viewsCount',
            'likesCount',
            'repostsCount',
            'commentsCount',
            'likes',
            'postSource',
            'geo',
            'copyHistory',
            'attachments'
        ]);
    }
}

const { PHOTO } = attachmentTypes;
const SMALL_SIZES = ['m', 's'];
const MEDIUM_SIZES = ['y', 'r', 'q', 'p', ...SMALL_SIZES];
const LARGE_SIZES = ['w', 'z', ...MEDIUM_SIZES];
class PhotoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(PHOTO, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'album_id' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [photo] = await this.vk.api.photos.getById({
            photos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = photo;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the ID of the user who uploaded the image
     */
    get userId() {
        return this.payload.user_id || null;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id || null;
    }
    /**
     * Returns the photo text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the date when this photo was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the photo height
     */
    get height() {
        return this.payload.height || null;
    }
    /**
     * Returns the photo width
     */
    get width() {
        return this.payload.width || null;
    }
    /**
     * Returns the URL of a small photo
     * (130 or 75)
     */
    get smallPhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(SMALL_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a medium photo
     * (807 or 604 or less)
     */
    get mediumPhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(MEDIUM_SIZES);
        return size.url;
    }
    /**
     * Returns the URL of a large photo
     * (2560 or 1280 or less)
     */
    get largePhoto() {
        if (!this.$filled) {
            return null;
        }
        const [size] = this.getSizes(LARGE_SIZES);
        return size.url;
    }
    /**
     * Returns the sizes
     */
    get sizes() {
        return this.payload.sizes || null;
    }
    /**
     * Returns the sizes of the required types
     */
    getSizes(sizeTypes) {
        const { sizes } = this;
        return sizeTypes
            .map((sizeType) => (sizes.find((size) => size.type === sizeType) || null))
            .filter(Boolean);
    }
    /**
     * Returns the custom data
     *
     * @type {Object}
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'albumId',
            'text',
            'createdAt',
            'height',
            'width',
            'smallPhoto',
            'mediumPhoto',
            'largePhoto',
            'sizes'
        ]);
    }
}

const { LINK } = attachmentTypes;
const kPhoto = Symbol('kPhoto');
class LinkAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(LINK, payload);
        this.vk = vk;
    }
    /**
     * Checks for the presence of a photo in a link
     */
    get hasPhoto() {
        return Boolean(this[kPhoto]);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title;
    }
    /**
     * Returns the title
     */
    get caption() {
        return this.payload.caption || null;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description || null;
    }
    /**
     * Returns the URL of the link
     */
    get url() {
        return this.payload.url;
    }
    /**
     * Returns the product
     */
    get product() {
        return this.payload.product;
    }
    /**
     * Returns the button
     */
    get button() {
        return this.payload.button || null;
    }
    /**
     * Returns the photo
     */
    get photo() {
        if (!this[kPhoto]) {
            this[kPhoto] = this.payload.photo
                ? new PhotoAttachment(this.payload.photo, this.vk)
                : null;
        }
        return this[kPhoto];
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'caption',
            'description',
            'url',
            'product',
            'button',
            'photo'
        ]);
    }
}

const { AUDIO } = attachmentTypes;
class AudioAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(AUDIO, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'duration' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [audio] = await this.vk.api.audio.getById({
            audios: `${this.ownerId}_${this.id}`
        });
        this.payload = audio;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether audio is in high quality
     */
    get isHq() {
        const { is_hq: isHq } = this.payload;
        if (isHq === undefined) {
            return null;
        }
        return isHq === 1;
    }
    /**
     * Returns the ID of the lyric
     */
    get lyricsId() {
        return this.payload.lyrics_id || null;
    }
    /**
     * Returns the ID of the album
     */
    get albumId() {
        return this.payload.album_id || null;
    }
    /**
     * Returns the ID of the genre
     */
    get genreId() {
        return this.payload.genre_id || null;
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the artist
     */
    get artist() {
        return this.payload.artist || null;
    }
    /**
     * Returns the duration
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the date object when this audio was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the URL of the audio
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'lyricsId',
            'albumId',
            'genreId',
            'title',
            'artist',
            'duration',
            'createdAt',
            'url'
        ]);
    }
}

const { VIDEO } = attachmentTypes;
class VideoAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(VIDEO, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const { items } = await this.vk.api.video.get({
            videos: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        const [video] = items;
        this.payload = video;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks whether the video is repeatable
     */
    get isRepeat() {
        return this.checkBooleanInProperty('repeat');
    }
    /**
     * Checks that the user can add a video to himself
     */
    get isCanAdd() {
        return this.checkBooleanInProperty('can_add');
    }
    /**
     * Checks if the user can edit the video
     */
    get isCanEdit() {
        return this.checkBooleanInProperty('can_edit');
    }
    /**
     * Checks whether the video is being processed
     */
    get isProcessing() {
        return this.checkBooleanInProperty('processing');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isBroadcast() {
        return this.checkBooleanInProperty('live');
    }
    /**
     * Checks whether the video is a broadcast
     */
    get isUpcoming() {
        return this.checkBooleanInProperty('upcoming');
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
    /**
     * Returns the title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the description
     */
    get description() {
        return this.payload.description || null;
    }
    /**
     * Returns the duration
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the date when this video was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the date when this video was added
     */
    get addedAt() {
        return this.payload.adding_date || null;
    }
    /**
     * Returns the count views
     */
    get viewsCount() {
        return this.payload.views || null;
    }
    /**
     * Returns the count comments
     */
    get commentsCount() {
        return this.payload.comments || null;
    }
    /**
     * Returns the URL of the page with the player
     */
    get player() {
        return this.payload.player || null;
    }
    /**
     * Returns the name of the platform (for video recordings added from external sites)
     */
    get platformName() {
        return this.payload.platform || null;
    }
    /**
     * Checks for a boolean value in the property
     */
    checkBooleanInProperty(name) {
        const property = this.payload[name];
        if (typeof property !== 'number') {
            return null;
        }
        return property === 1;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'description',
            'duration',
            'createdAt',
            'addedAt',
            'viewsCount',
            'commentsCount',
            'player',
            'platformName'
        ]);
    }
}

const { MARKET } = attachmentTypes;
class MarketAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(MARKET, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'title' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [market] = await this.vk.api.market.getById({
            item_ids: `${this.ownerId}_${this.id}`,
            extended: 0
        });
        this.payload = market;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks is bookmarked current user
     */
    get isFavorited() {
        if (!this.$filled) {
            return null;
        }
        return Boolean(this.payload.is_favorite);
    }
}

const { STICKER } = attachmentTypes;
class StickerAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(STICKER, payload);
        this.vk = vk;
    }
    /**
     * Returns the identifier sticker
     */
    get id() {
        return this.payload.sticker_id;
    }
    /**
     * Returns the identifier product
     */
    get productId() {
        return this.payload.product_id;
    }
    /**
     * Returns the images sizes
     */
    get images() {
        return this.payload.images || [];
    }
    /**
     * Returns the images sizes with backgrounds
     */
    get imagesWithBackground() {
        return this.payload.images_with_background || [];
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'productId',
            'images',
            'imagesWithBackground'
        ]);
    }
}

const { GRAFFITI } = attachmentTypes;
class GraffitiAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(GRAFFITI, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'url' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the graffiti height
     */
    get height() {
        return this.payload.height || null;
    }
    /**
     * Returns the graffiti width
     */
    get width() {
        return this.payload.width || null;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the custom data
     *
     * @type {Object}
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'height',
            'width',
            'url'
        ]);
    }
}

const { DOCUMENT } = attachmentTypes;
/**
 * Types of documents
 *
 * @type {Map}
 */
const documentTypes = new Map([
    [1, 'text'],
    [2, 'archive'],
    [3, 'gif'],
    [4, 'image'],
    [5, 'audio'],
    [6, 'video'],
    [7, 'book'],
    [8, 'unknown']
]);
class DocumentAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(DOCUMENT, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'ext' in payload && 'date' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Checks if the document is a text
     */
    get isText() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 1;
    }
    /**
     * Checks if the document is a archive
     */
    get isArchive() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 2;
    }
    /**
     * Checks if the document is a gif file
     */
    get isGif() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 3;
    }
    /**
     * Checks if the document is a image
     */
    get isImage() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 4;
    }
    /**
     * Checks if the document is a graffiti
     */
    get isGraffiti() {
        if (!this.$filled) {
            return null;
        }
        return this.hasPreviewProperty('graffiti');
    }
    /**
     * Checks if the document is a audio
     */
    get isAudio() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 5;
    }
    /**
     * Checks if the document is a voice
     */
    get isVoice() {
        if (!this.$filled) {
            return null;
        }
        return this.hasPreviewProperty('audio_msg');
    }
    /**
     * Checks if the document is a video
     */
    get isVideo() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 6;
    }
    /**
     * Checks if the document is a book
     */
    get isBook() {
        if (!this.$filled) {
            return null;
        }
        return this.typeId === 7;
    }
    /**
     * Returns the document title
     */
    get title() {
        return this.payload.title || null;
    }
    /**
     * Returns the date when this document was created
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the type identifier (1~8)
     */
    get typeId() {
        return this.payload.type || null;
    }
    /**
     * Returns the type name
     */
    get typeName() {
        if (!this.$filled) {
            return null;
        }
        return documentTypes.get(this.typeId);
    }
    /**
     * Returns the size in bytes
     */
    get size() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.size;
    }
    /**
     * Returns the extension
     */
    get extension() {
        return this.payload.ext || null;
    }
    /**
     * Returns the URL of the document
     */
    get url() {
        return this.payload.url || null;
    }
    /**
     * Returns the info to preview
     */
    get preview() {
        return this.payload.preview || null;
    }
    /**
     * Checks for a property in preview
     */
    hasPreviewProperty(name) {
        const { preview } = this;
        if (preview === null) {
            return false;
        }
        return name in preview;
    }
    /**
     * Returns the custom data
     *
     * @type {Object}
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'title',
            'typeId',
            'typeName',
            'createdAt',
            'extension',
            'url'
        ]);
    }
}

const { WALL_REPLY } = attachmentTypes;
class WallReplyAttachment extends ExternalAttachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(WALL_REPLY, payload);
        this.vk = vk;
    }
}

const { MARKET_ALBUM } = attachmentTypes;
class MarketAlbumAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(MARKET_ALBUM, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'title' in payload && 'updated_time' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [album] = await this.vk.api.market.getAlbumById({
            owner_id: this.ownerId,
            album_ids: this.id
        });
        this.payload = album;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
}

const { AUDIO_MESSAGE } = attachmentTypes;
class AudioMessageAttachment extends Attachment {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        super(AUDIO_MESSAGE, payload.owner_id, payload.id, payload.access_key);
        this.vk = vk;
        this.payload = payload;
        this.$filled = 'duration' in payload;
    }
    /**
     * Load attachment payload
     */
    async loadAttachmentPayload() {
        if (this.$filled) {
            return;
        }
        // @ts-ignore
        const [document] = await this.vk.api.docs.getById({
            docs: `${this.ownerId}_${this.id}`
        });
        this.payload = document;
        if ('access_key' in this.payload) {
            this.accessKey = this.payload.access_key;
        }
        this.$filled = true;
    }
    /**
     * Returns the duration of the audio message
     */
    get duration() {
        if (!this.$filled) {
            return null;
        }
        return this.payload.duration;
    }
    /**
     * Returns the waveform of the audio message
     */
    get waveform() {
        return this.payload.waveform || null;
    }
    /**
     * Returns the ogg URL of the audio message
     */
    get oggUrl() {
        return this.payload.link_ogg || null;
    }
    /**
     * Returns the mp3 URL of the audio message
     */
    get mp3Url() {
        return this.payload.link_mp3 || null;
    }
    /**
     * Returns the URL of the audio message
     */
    get url() {
        return this.mp3Url || this.oggUrl;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const payload = copyParams(this, [
            'duration',
            'waveform',
            'oggUrl',
            'mp3Url',
            'url'
        ]);
        // @ts-ignore
        payload.waveform = `[...${this.waveform.length} elements]`;
        return payload;
    }
}

const { MISSING_PARAMETERS, NO_FILES_TO_UPLOAD, EXCEEDED_MAX_FILES, UNSUPPORTED_SOURCE_TYPE } = uploadErrors;
const isURL = /^https?:\/\//i;
class Upload {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
        this.graffiti = deprecate(params => (
        // @ts-ignore
        this.messageGraffiti(params)), 'graffiti(params) is deprecated, use messageGraffiti(params) instead');
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Upload';
    }
    /**
     * Uploading photos to an album
     */
    async photoAlbum(params) {
        const photos = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getUploadServer,
            serverParams: ['album_id', 'group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.save,
            saveParams: ['album_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 5,
            attachmentType: 'photo'
        });
        return photos.map(photo => (new PhotoAttachment(photo, this.vk)));
    }
    /**
     * Uploading photos to the wall
     */
    async wallPhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getWallUploadServer,
            serverParams: ['group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveWallPhoto,
            saveParams: ['user_id', 'group_id', 'latitude', 'longitude', 'caption'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploading the main photo of a user or community
     */
    ownerPhoto(params) {
        return this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getOwnerPhotoUploadServer,
            serverParams: ['owner_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveOwnerPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   photo_hash: 'c8d43da5e1281b7aed6bb8f0c4f3ad69',
        //   photo_src: 'https://pp.userapi.com/c836429/v836429114/673f6/5VJB8GXtK88.jpg',
        //   photo_src_big: 'https://pp.userapi.com/c836429/v836429114/673f7/7fGvrJ1wOx0.jpg',
        //   photo_src_small: 'https://pp.userapi.com/c836429/v836429114/673f5/l5d1ASgyuxk.jpg',
        //   saved: 1,
        //   post_id: 3331
        // }
    }
    /**
     * Uploading a photo to a private message
     */
    async messagePhoto(params) {
        const [photo] = await this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMessagesUploadServer,
            serverParams: ['peer_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMessagesPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploading the main photo for a chat
     */
    chatPhoto(params) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getChatUploadServer,
            serverParams: ['chat_id', 'crop_x', 'crop_y', 'crop_width'],
            saveFiles: file => (
            // @ts-ignore
            this.vk.api.messages.setChatPhoto({ file })),
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //   message_id: 3745390,
        //   chat: {
        //    id: 152,
        //    type: 'chat',
        //    title: '<Titile name>',
        //    admin_id: 335447860,
        //    users: [335447860,
        //      140192020,
        //      153711615,
        //      314650825,
        //      218747758,
        //      155944103,
        //      159737827,
        //      64299368,
        //      157534541,
        //      153608064,
        //      335540121,
        //      349609849,
        //      344184938,
        //      341178526,
        //      198210835,
        //      135446999,
        //      163850606,
        //      123640861,
        //      316216798,
        //      359118107,
        //      241235369,
        //      160213445,
        //      126624591,
        //      390221395,
        //      195624402,
        //      94955334,
        //      167302501,
        //      17516523,
        //      294583792,
        //      294869767,
        //      114281676,
        //      137762280,
        //      406076540,
        //      410605840,
        //      395646590,
        //      421554042,
        //      331599090,
        //      342269712
        //    ],
        //    photo_50: 'https://pp.userapi.com/c837624/v837624114/5d495/gLgv-JrVmkk.jpg',
        //    photo_100: 'https://pp.userapi.com/c837624/v837624114/5d494/VNp61I1yuCk.jpg',
        //    photo_200: 'https://pp.userapi.com/c837624/v837624114/5d492/lAoc_fAai2Q.jpg'
        //   }
        // }
    }
    /**
     * Uploading a photo for a product
     */
    async marketPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMarketUploadServer,
            serverParams: ['group_id', 'main_photo', 'crop_x', 'crop_y', 'crop_width'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMarketPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploads a photo for the selection of goods
     */
    async marketAlbumPhoto(params) {
        const [photo] = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getMarketAlbumUploadServer,
            serverParams: ['group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveMarketAlbumPhoto,
            saveParams: ['group_id'],
            maxFiles: 1,
            attachmentType: 'photo'
        });
        return new PhotoAttachment(photo, this.vk);
    }
    /**
     * Uploads audio
     */
    async audio(params) {
        const audio = await this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.audio.getUploadServer,
            // @ts-ignore
            saveFiles: this.vk.api.audio.save,
            saveParams: ['title', 'artist'],
            maxFiles: 1,
            attachmentType: 'audio'
        });
        return new AudioAttachment(audio, this.vk);
    }
    /**
     * Uploads video
     */
    async video(params) {
        // @ts-ignore
        const save = await this.vk.api.video.save(copyParams$1(params, [
            'group_id',
            'album_id',
            'link',
            'name',
            'description',
            'is_private',
            'wallpost',
            'privacy_view',
            'privacy_comment',
            'no_comments',
            'repeat',
            'compression'
        ]));
        save.id = save.video_id;
        if ('link' in params) {
            const response = await fetch(save.upload_url, {
                agent: this.vk.options.agent
            });
            await response.json();
            return new VideoAttachment(save, this.vk);
        }
        let { source } = params;
        if (typeof source !== 'object' || source.constructor !== Object) {
            // @ts-ignore
            source = {
                values: source
            };
        }
        // @ts-ignore
        if (!Array.isArray(source.values)) {
            // @ts-ignore
            source.values = [source.values];
        }
        const formData = await this.buildPayload({
            maxFiles: 1,
            field: 'video_file',
            attachmentType: 'video',
            // @ts-ignore
            values: source.values
        });
        const video = await this.upload(save.upload_url, {
            formData,
            forceBuffer: true,
            // @ts-ignore
            timeout: source.timeout
        });
        return new VideoAttachment({ ...save, ...video }, this.vk);
    }
    /**
     * Uploads document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductDocument(params, { attachmentType = 'doc' } = {}) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getUploadServer,
            serverParams: ['type', 'group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
    }
    /**
     * Uploads document
     */
    async document(params) {
        const { doc: document } = await this.conductDocument(params, {
            attachmentType: 'doc'
        });
        return new DocumentAttachment(document, this.vk);
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductWallDocument(params, { attachmentType = 'doc' } = {}) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getWallUploadServer,
            serverParams: ['type', 'group_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
    }
    /**
     * Uploads wall document
     */
    async wallDocument(params) {
        const { doc: document } = await this.conductWallDocument(params, {
            attachmentType: 'doc'
        });
        return new DocumentAttachment(document, this.vk);
    }
    /**
     * Uploads wall document
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async conductMessageDocument(params, { attachmentType = 'doc' } = {}) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.docs.getMessagesUploadServer,
            serverParams: ['type', 'peer_id'],
            // @ts-ignore
            saveFiles: this.vk.api.docs.save,
            saveParams: ['title', 'tags'],
            maxFiles: 1,
            attachmentType
        });
    }
    /**
     * Uploads message document
     */
    async messageDocument(params) {
        const { doc: document } = await this.conductMessageDocument(params, {
            attachmentType: 'doc'
        });
        return new DocumentAttachment(document, this.vk);
    }
    /**
     * Uploads audio message
     */
    async audioMessage(params) {
        const { audio_message: audioMessage } = await this.conductMessageDocument({
            ...params,
            type: 'audio_message'
        }, {
            attachmentType: 'audioMessage'
        });
        const audioMessageAttachment = new AudioMessageAttachment(audioMessage, this.vk);
        return audioMessageAttachment;
        // { type: 'audio_message',
        // audio_message: {
        //   id: 484017542,
        //   owner_id: 195624402,
        //   duration: 48,
        //   waveform: [...],
        //   link_ogg:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.ogg',
        //   link_mp3:
        //   'https://psv4.userapi.com/c805324//u195624402/audiomsg/15734aa6bb.mp3',
        //   access_key: '295cc90411e6222db0' } }
    }
    /**
     * Uploads graffiti in documents
     */
    async documentGraffiti(params) {
        const { graffiti } = await this.conductDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
        const graffitiAttachment = new GraffitiAttachment(graffiti, this.vk);
        return graffitiAttachment;
    }
    /**
     * Uploads graffiti in messages
     */
    async messageGraffiti(params) {
        const { graffiti } = await this.conductMessageDocument({
            ...params,
            type: 'graffiti'
        }, {
            attachmentType: 'graffiti'
        });
        const graffitiAttachment = new GraffitiAttachment(graffiti, this.vk);
        return graffitiAttachment;
    }
    /**
     * Uploads community cover
     */
    groupCover(params) {
        return this.conduct({
            field: 'photo',
            params,
            // @ts-ignore
            getServer: this.vk.api.photos.getOwnerCoverPhotoUploadServer,
            serverParams: ['group_id', 'crop_x', 'crop_y', 'crop_x2', 'crop_y2'],
            // @ts-ignore
            saveFiles: this.vk.api.photos.saveOwnerCoverPhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
        // {
        //  images: [
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46404/r-1Nhr-Dktc.jpg',
        //      width: 200,
        //      height: 50
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46403/oDB9tAgtUrQ.jpg',
        //      width: 400,
        //      height: 101
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46400/gLwCTmDEPXY.jpg',
        //      width: 795,
        //      height: 200
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46402/w2ucyq8zwF8.jpg',
        //      width: 1080,
        //      height: 272
        //    },
        //    {
        //      url: 'https://cs7056.userapi.com/c639526/v639526192/46401/YTmN89yMaU0.jpg',
        //      width: 1590,
        //      height: 400
        //    }
        //  ]
        // }
    }
    /**
     * Uploads photo stories
     */
    storiesPhoto(params) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.stories.getPhotoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id',
                'attach_access_key'
            ],
            saveFiles: save => save,
            maxFiles: 1,
            attachmentType: 'photo'
        });
    }
    /**
     * Uploads video stories
     */
    storiesVideo(params) {
        return this.conduct({
            field: 'video_file',
            params,
            // @ts-ignore
            getServer: this.vk.api.stories.getVideoUploadServer,
            serverParams: [
                'add_to_news',
                'user_ids',
                'reply_to_story',
                'link_text',
                'link_url',
                'group_id'
            ],
            saveFiles: save => save,
            maxFiles: 1,
            attachmentType: 'video',
            forceBuffer: true
        });
    }
    /**
     * Uploads poll photo
     */
    pollPhoto(params
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        return this.conduct({
            field: 'file',
            params,
            // @ts-ignore
            getServer: this.vk.api.polls.getPhotoUploadServer,
            serverParams: ['owner_id'],
            // @ts-ignore
            saveFiles: this.vk.api.polls.savePhoto,
            maxFiles: 1,
            attachmentType: 'photo'
        });
    }
    /**
     * Behavior for the upload method
     */
    async conduct({ field, params, getServer, serverParams = [], saveFiles, saveParams = [], maxFiles = 1, attachmentType, forceBuffer = false
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
     }) {
        if (!params || !params.source) {
            throw new UploadError({
                message: 'Missing upload params',
                code: MISSING_PARAMETERS
            });
        }
        let { source } = params;
        if (typeof source !== 'object'
            || source.constructor !== Object
            // @ts-ignore
            || source.value !== undefined) {
            // @ts-ignore
            source = {
                values: source
            };
        }
        // @ts-ignore
        if (!Array.isArray(source.values)) {
            // @ts-ignore
            source.values = [source.values];
        }
        // @ts-ignore
        if ('uploadUrl' in source) {
            // eslint-disable-next-line no-param-reassign
            getServer = () => ({
                // @ts-ignore
                upload_url: source.uploadUrl
            });
        }
        // @ts-ignore
        const { length: valuesLength } = source.values;
        if (valuesLength === 0) {
            throw new UploadError({
                message: 'No files to upload',
                code: NO_FILES_TO_UPLOAD
            });
        }
        if (valuesLength > maxFiles) {
            throw new UploadError({
                message: 'The number of files uploaded has exceeded',
                code: EXCEEDED_MAX_FILES
            });
        }
        const [{ upload_url: url }, formData] = await Promise.all([
            getServer(copyParams$1(params, serverParams)),
            this.buildPayload({
                field,
                // @ts-ignore
                values: source.values,
                maxFiles,
                attachmentType
            })
        ]);
        const uploaded = await this.upload(url, {
            formData,
            forceBuffer,
            // @ts-ignore
            timeout: source.timeout
        });
        if (typeof uploaded !== 'object') {
            const response = await saveFiles(uploaded);
            return response;
        }
        const response = await saveFiles({
            ...copyParams$1(params, saveParams),
            ...uploaded
        });
        return response;
    }
    /**
     * Building form data
     *
     * @param {Object} payload
     *
     * @return {Promise}
     */
    // eslint-disable-next-line class-methods-use-this
    async buildPayload({ field, values, maxFiles, attachmentType }) {
        const boundary = randomBytes(32).toString('hex');
        const formData = new MultipartStream(boundary);
        const isMultipart = maxFiles > 1;
        const tasks = values
            .map(value => (typeof value === 'object' && value.constructor === Object
            ? value
            : { value }))
            .map(async ({ value, filename, contentType = null }, i) => {
            if (typeof value === 'string') {
                if (isURL.test(value)) {
                    const response = await fetch(value);
                    // eslint-disable-next-line no-param-reassign
                    value = response.body;
                }
                else {
                    // eslint-disable-next-line no-param-reassign
                    value = createReadStream(value);
                }
            }
            if (!filename) {
                // eslint-disable-next-line no-param-reassign
                filename = `file${i}.${defaultExtensions[attachmentType] || 'dat'}`;
            }
            if (isStream(value) || Buffer.isBuffer(value)) {
                const name = isMultipart
                    ? field + (i + 1)
                    : field;
                const headers = {
                    'Content-Type': contentType === null
                        ? defaultContentTypes[attachmentType]
                        : contentType
                };
                return formData.append(name, value, { filename, headers });
            }
            throw new UploadError({
                message: 'Unsupported source type',
                code: UNSUPPORTED_SOURCE_TYPE
            });
        });
        await Promise.all(tasks);
        return formData;
    }
    /**
     * Upload form data
     *
     * @param {URL|string} url
     * @param {Object}     options
     *
     * @return {Promise<Object>}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async upload(url, { formData, timeout, forceBuffer }) {
        const { agent, uploadTimeout } = this.vk.options;
        const body = forceBuffer
            ? await streamToBuffer(formData)
            : formData;
        let response = await fetch(url, {
            agent,
            compress: false,
            method: 'POST',
            timeout: timeout || uploadTimeout,
            headers: {
                Connection: 'keep-alive',
                'Content-Type': `multipart/form-data; boundary=${formData.boundary}`
            },
            body
        });
        if (!response.ok) {
            throw new Error(response.statusText);
        }
        response = await response.json();
        return response.response !== undefined
            ? response.response
            : response;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        return `${options.stylize(name, 'special')} {}`;
    }
}

const unespaceOffset = /"offset":"(\w+)"/g;
var getExecuteCode = ({ method, params, parallelCount }) => {
    const methodCode = getExecuteMethod(method, {
        ...params,
        offset: 'offset'
    });
    const code = `
		var total = parseInt(Args.total);
		var offset = parseInt(Args.offset);
		var received = parseInt(Args.received);

		var proceed = total == 0 || received < total;

		var i = 0, items = [], profiles = [], groups = [], result, length;

		while (i < ${parallelCount} && proceed) {
			result = ${methodCode};
			length = result.items.length;

			if (total == 0 || total > result.count) {
				total = result.count;
			}

			items = items + result.items;
			if (result.profiles)
				profiles = profiles + result.profiles;
			if (result.groups)
				groups = groups + result.groups;

			offset = offset + length;
			received = received + length;

			proceed = received < total;
			i = i + 1;
		}

		return {
			total: total,
			items: items.splice(0, total),
			profiles: profiles.splice(0, total),
			groups: groups.splice(0, total)
		};
	`;
    return code.replace(unespaceOffset, '"offset":$1');
};

const debug$7 = createDebug('vk-io:collect:stream');
const { APP_TOKEN_NOT_VALID, RESPONSE_SIZE_TOO_BIG } = apiErrors;
const { EXECUTE_ERROR } = collectErrors;
class CollectStream extends Readable {
    /**
     * Constructor
     */
    constructor(vk, { options, method, limit, max = null }) {
        super({
            objectMode: true
        });
        this.vk = vk;
        const { parallelCount = 25, count = null, offset = 0, ...params } = options;
        this.method = method;
        this.params = {
            ...params,
            count: limit
        };
        if (parallelCount < 1 || parallelCount > 25) {
            throw new RangeError('The number of parallel calls can be between 1 and 25');
        }
        this.parallelCount = parallelCount;
        const hasMax = max !== null;
        const hasCount = count !== null;
        if ((hasCount && hasMax && count > max) || (hasMax && !hasCount)) {
            this.total = max;
        }
        else {
            this.total = count;
        }
        this.offset = offset;
        this.skipOffset = offset;
        this.received = 0;
        this.attempts = 0;
        this.promise = null;
        this.supportExecute = true;
        this.code = getExecuteCode({
            params: this.params,
            parallelCount,
            method
        });
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'CollectStream';
    }
    /**
     * Promise based
     *
     * @return {Promise<Object[]>}
     */
    then(thenFn, catchFn) {
        if (this.promise === null) {
            let collectItems = [];
            let collectProfiles = [];
            let collectGroups = [];
            this.promise = new Promise((resolve, reject) => {
                this
                    .on('error', reject)
                    .on('end', () => resolve({
                    items: collectItems,
                    profiles: collectProfiles,
                    groups: collectGroups
                }))
                    .on('data', ({ items, profiles, groups }) => {
                    collectItems = [...collectItems, ...items];
                    collectProfiles = [...collectProfiles, ...profiles];
                    collectGroups = [...collectGroups, ...groups];
                });
            });
        }
        return Promise.resolve(this.promise).then(thenFn, catchFn);
    }
    /**
     * Fetch data
     */
    // eslint-disable-next-line no-underscore-dangle
    async _read() {
        const isNotFirst = this.total !== null && this.received !== 0;
        if (isNotFirst && (this.total - this.skipOffset) <= this.received) {
            this.push(null);
            return;
        }
        let items;
        let profiles;
        let groups;
        if (!this.supportExecute || this.parallelCount === 1) {
            const request = new Request(this.method, {
                ...this.params,
                offset: this.offset
            });
            let result;
            try {
                result = await this.vk.api.callWithRequest(request);
            }
            catch (error) {
                const { collectAttempts } = this.vk.options;
                if (this.attempts >= collectAttempts) {
                    this.emit('error', error);
                    return;
                }
                this.attempts += 1;
                // eslint-disable-next-line no-underscore-dangle
                this._read();
                return;
            }
            const { count, items: collectItems, profiles: collectProfiles, groups: collectGroups } = result;
            if (this.total === null || this.total > count) {
                this.total = count;
            }
            [items, profiles, groups] = [collectItems, collectProfiles, collectGroups];
        }
        else {
            let result;
            try {
                result = await this.vk.api.execute({
                    code: this.code,
                    total: this.total,
                    offset: this.offset,
                    received: this.received
                });
            }
            catch (error) {
                if (error.code === APP_TOKEN_NOT_VALID) {
                    this.supportExecute = false;
                    debug$7('execute not supported in token');
                    // eslint-disable-next-line no-underscore-dangle
                    this._read();
                    return;
                }
                if (error.code === RESPONSE_SIZE_TOO_BIG) {
                    this.parallelCount -= 1;
                    this.code = getExecuteCode({
                        parallelCount: this.parallelCount,
                        params: this.params,
                        method: this.method
                    });
                    // eslint-disable-next-line no-underscore-dangle
                    this._read();
                    return;
                }
                const { collectAttempts } = this.vk.options;
                if (this.attempts >= collectAttempts) {
                    this.emit('error', error);
                    return;
                }
                this.attempts += 1;
                // eslint-disable-next-line no-underscore-dangle
                this._read();
                return;
            }
            const { response, errors } = result;
            if (errors.length > 0) {
                this.emit('error', new CollectError({
                    message: 'Execute error',
                    code: EXECUTE_ERROR,
                    errors
                }));
                return;
            }
            const { total, items: collectItems, profiles: collectProfiles, groups: collectGroups } = response;
            this.total = total;
            [items, profiles, groups] = [collectItems, collectProfiles, collectGroups];
        }
        const { length } = items;
        if (length === 0) {
            this.push(null);
            return;
        }
        this.offset += length;
        this.received += length;
        const { total, received } = this;
        let percent = Math.round((received / total) * 100);
        if (Number.isNaN(percent)) {
            percent = 100;
        }
        this.push({
            received,
            percent,
            total,
            items,
            profiles,
            groups
        });
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { total, offset, received } = this;
        const payload = {
            total,
            offset,
            received
        };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * List limits VK
 * Last updated 09.10.2017
 */
var LIMITS_METHODS = [
    /**
     * Account
     */
    ['account.getActiveOffers', 100],
    ['account.getBanned', 200],
    /**
     * Ads
     */
    ['ads.getAds', 100, 2000],
    ['ads.getAdsLayout', 100, 2000],
    ['ads.getAdsTargeting', 100, 2000],
    /**
     * Apps
     */
    ['apps.getCatalog', 100],
    ['apps.getFriendsList', 5000],
    /**
     * Audio
     */
    ['audio.get', 6000],
    ['audio.search', 300, 1000],
    ['audio.getAlbums', 100],
    ['audio.getRecommendations', 1000],
    ['audio.getPopular', 1000],
    /**
     * Board
     */
    ['board.getComments', 100],
    ['board.getTopics', 100],
    /**
     * Database
     */
    ['database.getChairs', 10000],
    ['database.getCities', 1000],
    ['database.getCountries', 1000],
    ['database.getFaculties', 10000],
    ['database.getRegions', 1000],
    ['database.getSchools', 10000],
    ['database.getUniversities', 10000],
    /**
     * Docs
     */
    ['docs.get', 2000, 2000],
    ['docs.search', 1000, 1000],
    /**
     * Fave
     */
    ['fave.getPosts', 100],
    ['fave.getLinks', 100],
    ['fave.getMarketItems', 100],
    ['fave.getPhotos', 100],
    ['fave.getUsers', 100],
    ['fave.getVideos', 100],
    /**
     * Friends
     */
    ['friends.get', 1000],
    ['friends.getMutual', 1000],
    ['friends.getMutual', 1000],
    ['friends.getOnline', 1000],
    ['friends.getRecent', 1000],
    ['friends.getRequests', 1000],
    ['friends.getSuggestions', 500],
    ['friends.search', 1000],
    /**
     * Gifts
     */
    ['gifts.get', 100],
    /**
     * Groups
     */
    ['groups.get', 1000],
    ['groups.getBanned', 200],
    ['groups.getInvitedUsers', 100],
    ['groups.getInvites', 100],
    ['groups.getMembers', 1000],
    ['groups.getRequests', 200],
    /**
     * Leads
     */
    ['leads.getUsers', 1000],
    /**
     * Likes
     */
    ['likes.getList', 100],
    /**
     * Market
     */
    ['market.get', 200],
    ['market.getAlbums', 100],
    ['market.getCategories', 1000],
    ['market.getComments', 100],
    ['market.search', 200],
    /**
     * messages
     */
    ['messages.get', 200],
    ['messages.getHistory', 200],
    ['messages.search', 100],
    ['messages.getConversations', 200],
    /**
     * Notes
     */
    ['notes.get', 100],
    ['notes.getComments', 100],
    /**
     * Orders
     */
    ['orders.get', 1000],
    /**
     * Photos
     */
    ['photos.get', 1000],
    ['photos.getAlbums', 100],
    ['photos.getAll', 200],
    ['photos.getAllComments', 100],
    ['photos.getComments', 100],
    ['photos.getNewTags', 100],
    ['photos.getUserPhotos', 1000],
    ['photos.search', 1000],
    /**
     * Places
     */
    ['places.getCheckins', 100],
    ['places.search', 1000],
    /**
     * Polls
     */
    ['polls.getVoters', 100],
    /**
     * Storage
     */
    ['storage.getKeys', 1000],
    /**
     * Users
     */
    ['users.getFollowers', 1000],
    ['users.getSubscriptions', 200],
    ['users.search', 1000, 1000],
    /**
     * Utils
     */
    ['utils.getLastShortenedLinks', 50],
    /**
     * Video
     */
    ['video.get', 200],
    ['video.getAlbums', 100],
    ['video.getComments', 100],
    ['video.search', 1000, 1000],
    /**
     * Wall
     */
    ['wall.get', 100],
    ['wall.getComments', 100],
    ['wall.getReposts', 1000],
    ['wall.search', 100],
    /**
     * Widgets
     */
    ['widgets.getComments', 200],
    ['widgets.getPages', 200]
];

class Chain {
    /**
     * Constructor
     */
    constructor(vk) {
        this.started = false;
        this.queue = [];
        this.vk = vk;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Chain';
    }
    /**
     * Adds method to queue
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    append(method, params) {
        if (this.started) {
            return Promise.reject(new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            }));
        }
        const request = new Request(method, params);
        this.queue.push(request);
        return request.promise;
    }
    /**
     * Promise based
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    then(thenFn, catchFn) {
        return Promise.resolve(this.run()).then(thenFn, catchFn);
    }
    /**
     * Starts the chain
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async run() {
        if (this.started) {
            throw new VKError({
                message: 'Chain already started',
                code: 'ALREADY_STARTED'
            });
        }
        this.started = true;
        const { queue } = this;
        let out = {
            response: [],
            errors: []
        };
        if (queue.length === 0) {
            return out;
        }
        while (queue.length > 0) {
            const tasks = queue.splice(0, 25);
            const code = getChainReturn(tasks.map(String));
            try {
                const response = await this.vk.api.execute({ code });
                resolveExecuteTask(tasks, response);
                out = {
                    response: [...out.response, ...response.response],
                    errors: [...out.errors, ...response.errors]
                };
            }
            catch (error) {
                for (const task of tasks) {
                    task.reject(error);
                }
                throw error;
            }
        }
        return out;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { started, queue } = this;
        const payload = { started, queue };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

class Collect {
    /**
     * constructor
     */
    constructor(vk) {
        this.vk = vk;
        for (const [method, limit, max] of LIMITS_METHODS) {
            const [group, name] = method.split('.');
            if (!(group in this)) {
                this[group] = {};
            }
            this[group][name] = (options = {}) => (new CollectStream(this.vk, {
                options,
                method,
                limit,
                max
            }));
        }
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Collect';
    }
    /**
     * Returns new Chain instance
     */
    chain() {
        return new Chain(this.vk);
    }
    /**
     * Call multiple executors
     *
     * @param {string} method
     * @param {Array}  queue
     *
     * @return {Promise<Array>}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async executes(method, queue) {
        const queueMethods = queue.map(params => (getExecuteMethod(method, params)));
        const promises = [];
        while (queueMethods.length !== 0) {
            const code = getChainReturn(queueMethods.splice(0, 25));
            promises.push(this.vk.api.execute({ code }));
        }
        let out = {
            response: [],
            errors: []
        };
        for (const { response, errors } of await Promise.all(promises)) {
            out = {
                response: [...out.response, ...response],
                errors: [...out.errors, ...errors]
            };
        }
        return out;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        return `${options.stylize(name, 'special')} {}`;
    }
}

class Context {
    /**
     * Constructor
     */
    constructor(options) {
        this.vk = options.vk;
        this.type = options.type;
        this.subTypes = options.subTypes;
        this.payload = options.payload;
        // @ts-ignore
        this.state = options.state || {};
        this.$groupId = options.groupId;
    }
    /**
     * Returns custom tag
     */
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    /**
     * Checks whether the context of some of these types
     */
    is(rawTypes) {
        const types = !Array.isArray(rawTypes)
            ? [rawTypes]
            : rawTypes;
        return [this.type, ...this.subTypes].some((type) => (types.includes(type)));
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return {
            ...this[inspectCustomData](),
            type: this.type,
            subTypes: this.subTypes,
            state: this.state
        };
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { vk, ...payload } = this;
        return payload;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const customData = {
            ...this[inspectCustomData](),
            type: this.type,
            subTypes: this.subTypes,
            state: this.state
        };
        const payload = inspect(customData, { ...options, compact: false });
        return `${options.stylize(name, 'special')} ${payload}`;
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VoteContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vote',
            subTypes: [
                'pull_vote'
            ]
        });
    }
    /**
     * Returns the identifier poll
     */
    get id() {
        return this.payload.poll_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier owner
     */
    get ownerId() {
        return this.payload.owner_id;
    }
    /**
     * Returns the identifier option
     */
    get optionId() {
        return this.payload.option_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'userId',
            'ownerId',
            'optionId'
        ]);
    }
}

const transformPolling = ({ 1: fromId, 2: toId }, updateType) => ({
    from_id: fromId,
    to_id: updateType === 62
        ? toId + CHAT_PEER
        : fromId,
    state: 'typing'
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class TypingContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'typing',
            subTypes: [
                // @ts-ignore
                `typing_${getPeerType(options.payload.from_id)}`
            ],
            payload: options.source === updatesSources.POLLING
                // @ts-ignore
                ? transformPolling(options.payload, options.updateType)
                : options.payload
        });
    }
    /**
     * Checks is typing
     */
    get isTyping() {
        return this.payload.state === 'typing';
    }
    /**
     * Checks is record audio message
     */
    get isAudioMessage() {
        return this.payload.state === 'audiomessage';
    }
    /**
     * Checks that the message is typed in the dm
     */
    get isUser() {
        return this.subTypes.includes('typing_user');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isGroup() {
        return this.subTypes.includes('typing_group');
    }
    /**
     * Checks that the message is typed in the chat
     */
    get isChat() {
        return this.chatId !== null;
    }
    /**
     * Returns the identifier sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the identifier destination
     */
    get toId() {
        return this.payload.to_id;
    }
    /**
     * Returns the identifier peer
     */
    // DEPRECATED: Remove in release version
    get peerId() {
        showDeprecatedMessage('TypingContext, use toId instead of peerId');
        return this.toId;
    }
    /**
     * Returns the identifier user
     */
    // DEPRECATED: Remove in release version
    get userId() {
        showDeprecatedMessage('TypingContext, use fromId instead of userId');
        return this.fromId;
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        const chatId = this.toId - CHAT_PEER;
        return chatId > 0
            ? chatId
            : null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'fromId',
            'toId',
            'chatId',
            'isUser',
            'isGroup',
            'isChat',
            'isTyping',
            'isAudioMessage'
        ]);
    }
}

const kAttachments$1 = Symbol('attachments');
class MessageReply {
    /**
     * Constructor
     */
    constructor(payload, vk) {
        this.vk = vk;
        this.payload = payload;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'MessageForward';
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return this.text !== null;
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Returns the identifier message
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.payload.conversation_message_id || null;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this message was updated
     */
    get updatedAt() {
        return this.payload.update_time;
    }
    /**
     * Returns the message text
     */
    get senderId() {
        return this.payload.from_id;
    }
    /**
     * Returns the message text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$1]) {
            this[kAttachments$1] = transformAttachments(this.payload.attachments, this.vk);
        }
        return this[kAttachments$1];
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments'
        ]);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const payload = copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments'
        ]);
        return `${options.stylize(name, 'special')} ${inspect(payload, { ...options, compact: false })}`;
    }
}

const kForwards = Symbol('forwards');
const kAttachments$2 = Symbol('attachments');
class MessageForward {
    /**
     * Constructor
     */
    constructor(options) {
        this.vk = options.vk;
        this.payload = options.payload;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'MessageForward';
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return this.text !== null;
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the date when this message was updated
     */
    get updatedAt() {
        return this.payload.update_time;
    }
    /**
     * Returns the message text
     */
    get senderId() {
        return this.payload.from_id;
    }
    /**
     * Returns the message text
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the forwards
     */
    get forwards() {
        if (!this[kForwards]) {
            this[kForwards] = this.payload.fwd_messages
                ? this.payload.fwd_messages.map(forward => (new MessageForward({
                    vk: this.vk,
                    payload: forward
                })))
                : [];
        }
        return this[kForwards];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$2]) {
            this[kAttachments$2] = transformAttachments(this.payload.attachments, this.vk);
        }
        return this[kAttachments$2];
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Returns data for JSON
     */
    toJSON() {
        return copyParams(this, [
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments',
            'forwards'
        ]);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const payload = copyParams(this, [
            'senderId',
            'createdAt',
            'updatedAt',
            'text',
            'attachments',
            'forwards'
        ]);
        return `${options.stylize(name, 'special')} ${inspect(payload, { ...options, compact: false })}`;
    }
}

/* eslint-disable @typescript-eslint/camelcase */
/**
 * Special attachments in one message
 */
const specialAttachments = {
    sticker: (raw) => ({
        type: 'sticker',
        sticker: {
            sticker_id: Number(raw.attach1),
            product_id: Number(raw.attach1_product_id)
        }
    }),
    money_transfer: (raw) => ({
        type: 'money_transfer',
        money_transfer: {
            data: raw.attach1,
            amount: Number(raw.attach1_amount),
            currency: Number(raw.attach1_currency)
        }
    }),
    gift: (raw) => ({
        type: 'gift',
        gift: {
            id: Number(raw.attach1)
        }
    })
};
/**
 * Transform message to Object
 */
function transformMessage({ 1: id, 2: flags, 3: peer, 4: date, 5: text, 6: extra, 7: attachments
// eslint-disable-next-line @typescript-eslint/no-explicit-any
 }) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const message = {
        id,
        date,
        text,
        flags,
        geo: 'geo' in attachments
            ? {}
            : null,
        random_id: extra.random_id || null,
        payload: extra.payload
            ? extra.payload
            : null
    };
    message.peer_id = peer;
    if ('from' in extra) {
        message.from_id = Number(extra.from);
    }
    else {
        message.from_id = peer;
    }
    if (peer < 0 && message.peer_id !== message.from_id) {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) === 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 1) !== 0;
    }
    else {
        // eslint-disable-next-line no-bitwise
        message.out = Number((flags & 2) !== 0);
        // eslint-disable-next-line no-bitwise
        message.important = (flags & 8) !== 0;
    }
    if ('source_act' in extra) {
        message.action = {
            type: extra.source_act,
            text: extra.source_text,
            member_id: extra.source_mid
        };
    }
    if (attachments.attach1_type in specialAttachments) {
        message.attachments = [
            specialAttachments[attachments.attach1_type](attachments)
        ];
    }
    else {
        const messageAttachments = [];
        for (let i = 1, key = 'attach1'; key in attachments; i += 1, key = `attach${i}`) {
            const type = attachments[`${key}_type`];
            if (type === 'link') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const attachment = {
                    type: 'link',
                    link: {
                        url: attachments[`${key}_url`],
                        title: attachments[`${key}_title`],
                        description: attachments[`${key}_desc`]
                    }
                };
                const photoKey = `${key}_photo`;
                if (attachments[photoKey]) {
                    const [owner, attachmentId] = attachments[photoKey].split('_');
                    attachment.link.photo = {
                        id: Number(attachmentId),
                        owner_id: Number(owner)
                    };
                }
                messageAttachments.push(attachment);
                continue;
            }
            const [owner, attachmentId] = attachments[key].split('_');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const attachment = {
                type,
                [type]: {
                    id: Number(attachmentId),
                    owner_id: Number(owner)
                }
            };
            const kindKey = `${key}_kind`;
            if (type === 'doc' && kindKey in attachments) {
                attachment[type].kind = attachments[kindKey];
            }
            messageAttachments.push(attachment);
        }
        message.attachments = messageAttachments;
    }
    let { fwd = null } = attachments;
    // Now long poll receive such forward messages 0_0,0_0
    if (fwd !== null) {
        const indexColon = fwd.indexOf(':');
        if (indexColon !== -1) {
            fwd = fwd.substring(0, indexColon);
        }
        message.fwd_messages = fwd
            .split(',')
            .map((attachment) => {
            const [owner] = attachment.split('_');
            return {
                date: 0,
                from_id: Number(owner),
                text: '',
                fwd_messages: [],
                attachments: [],
                update_time: 0
            };
        });
    }
    return message;
}

const getForwards = (rootForwards) => {
    const forwards = [];
    for (const forward of rootForwards) {
        forwards.push(forward, ...getForwards(forward.forwards));
    }
    return forwards;
};
const kFlatten = Symbol('flatten');
class MessageForwardsCollection extends Array {
    /**
     * Returns a flat copy of forwards
     */
    get flatten() {
        if (!this[kFlatten]) {
            this[kFlatten] = getForwards(this);
        }
        return this[kFlatten];
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        return this.flatten.some(forward => (forward.hasAttachments(type)));
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        const attachments = this.flatten.map(forward => (forward.getAttachments(type)));
        return [].concat(...attachments);
    }
}

const subTypesEnum = {
    4: 'new_message',
    5: 'edit_message',
    message_new: 'new_message',
    message_edit: 'edit_message',
    message_reply: 'reply_message'
};
const kForwards$1 = Symbol('forwards');
const kReplyMessage = Symbol('replyMessage');
const kAttachments$3 = Symbol('attachments');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message',
            subTypes: []
        });
        let { payload } = options;
        if (options.source === updatesSources.POLLING) {
            // eslint-disable-next-line no-param-reassign
            // @ts-ignore
            payload = transformMessage(payload);
            this.$filled = false;
        }
        else {
            this.$filled = true;
        }
        this.applyPayload(payload);
        this.subTypes = [
            this.eventType || subTypesEnum[options.updateType]
        ];
    }
    /**
     * Load message payload
     */
    async loadMessagePayload() {
        if (this.$filled) {
            return;
        }
        const { items } = this.id !== 0
            // @ts-ignore
            ? await this.vk.api.messages.getById({
                message_ids: this.id
            })
            // @ts-ignore
            : await this.vk.api.messages.getByConversationMessageId({
                peer_id: this.peerId,
                conversation_message_ids: this.conversationMessageId
            });
        const [message] = items;
        this[kForwards$1] = null;
        this[kAttachments$3] = null;
        this[kReplyMessage] = null;
        this.applyPayload(message);
        this.$filled = true;
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Checks if there is text
     */
    get hasText() {
        return Boolean(this.text);
    }
    /**
     * Checks for reply message
     */
    get hasReplyMessage() {
        return this.replyMessage !== null;
    }
    /**
     * Checks for forwarded messages
     */
    get hasForwards() {
        return this.forwards.length > 0;
    }
    /**
     * Checks for hast message payload
     */
    get hasMessagePayload() {
        return Boolean(this.payload.payload);
    }
    /**
     * Checks if there is text
     */
    get hasGeo() {
        return Boolean(this.payload.geo);
    }
    /**
     * Checks is a chat
     */
    get isChat() {
        return this.peerType === messageSources.CHAT;
    }
    /**
     * Check is a user
     */
    get isUser() {
        return this.senderType === messageSources.USER;
    }
    /**
     * Checks is a group
     */
    get isGroup() {
        return this.senderType === messageSources.GROUP;
    }
    /**
     * Checks is from the user
     */
    get isFromUser() {
        return this.peerType === messageSources.USER;
    }
    /**
     * Checks is from the group
     */
    get isFromGroup() {
        return this.peerType === messageSources.GROUP;
    }
    /**
     * Check is special event
     */
    get isEvent() {
        return this.eventType !== null;
    }
    /**
     * Checks whether the message is outbox
     */
    get isOutbox() {
        return Boolean(this.payload.out);
    }
    /**
     * Checks whether the message is inbox
     */
    get isInbox() {
        return !this.isOutbox;
    }
    /**
     * Checks that the message is important
     */
    get isImportant() {
        return this.payload.important;
    }
    /**
     * Returns the identifier message
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the conversation message id
     */
    get conversationMessageId() {
        return this.payload.conversation_message_id || null;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the peer type
     */
    get peerType() {
        return getPeerType(this.payload.peer_id);
    }
    /**
     * Returns the sender identifier
     */
    get senderId() {
        return this.payload.from_id;
    }
    /**
     * Returns the sender type
     */
    get senderType() {
        return getPeerType(this.payload.from_id);
    }
    /**
     * Returns the identifier chat
     */
    get chatId() {
        if (!this.isChat) {
            return null;
        }
        return this.peerId - CHAT_PEER;
    }
    /**
     * Returns the date when this message was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns geo
     *
     * @return {?Object}
     */
    get geo() {
        if (!this.hasGeo) {
            return null;
        }
        if (!this.$filled) {
            throw new VKError({
                message: 'The message payload is not fully loaded',
                code: 'PAYLOAD_IS_NOT_FULL'
            });
        }
        return this.payload.geo;
    }
    /**
     * Returns the event name
     */
    get eventType() {
        return (this.payload.action
            && this.payload.action.type) || null;
    }
    /**
     * Returns the event member id
     */
    get eventMemberId() {
        return (this.payload.action
            && this.payload.action.member_id) || null;
    }
    /**
     * Returns the event name
     */
    get eventText() {
        return (this.payload.action
            && this.payload.action.text) || null;
    }
    /**
     * Returns the event email
     */
    get eventEmail() {
        return (this.payload.action
            && this.payload.action.email) || null;
    }
    /**
     * Returns the message payload
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get messagePayload() {
        const { payload = null } = this.payload;
        if (payload === null) {
            return null;
        }
        return JSON.parse(payload);
    }
    /**
     * Returns the forwards
     */
    get forwards() {
        if (!this[kForwards$1]) {
            this[kForwards$1] = this.payload.fwd_messages
                ? new MessageForwardsCollection(...this.payload.fwd_messages.map(forward => (new MessageForward({
                    vk: this.vk,
                    // @ts-ignore
                    payload: forward
                }))))
                : new MessageForwardsCollection();
        }
        return this[kForwards$1];
    }
    /**
     * Returns the reply message
     */
    get replyMessage() {
        if (!this[kReplyMessage]) {
            this[kReplyMessage] = this.payload.reply_message
                ? new MessageReply(this.payload.reply_message, this.vk)
                : null;
        }
        return this[kReplyMessage];
    }
    /**
     * Returns the attachments
     */
    get attachments() {
        if (!this[kAttachments$3]) {
            this[kAttachments$3] = transformAttachments(this.payload.attachments, this.vk);
        }
        return this[kAttachments$3];
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Gets a link to invite the user to a conversation
     */
    getInviteLink(params = {}) {
        // @ts-ignore
        return this.vk.api.messages.getInviteLink({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Edits a message
     */
    editMessage(params) {
        // @ts-ignore
        return this.vk.api.messages.edit({
            attachment: this.attachments.filter(attachment => (attachment.canBeAttached)),
            message: this.text,
            keep_forward_messages: 1,
            keep_snippets: 1,
            ...params,
            peer_id: this.peerId,
            message_id: this.id
        });
    }
    /**
     * Edits a message text
     */
    async editMessageText(message) {
        const response = await this.editMessage({ message });
        this.text = message;
        return response;
    }
    /**
     * Sends a message to the current dialog
     */
    send(text, params) {
        // @ts-ignore
        return this.vk.api.messages.send({
            peer_id: this.peerId,
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        });
    }
    /**
     * Responds to the current message
     */
    reply(text, params) {
        return this.send({
            reply_to: this.id,
            ...(typeof text !== 'object'
                ? {
                    message: text,
                    ...params
                }
                : text)
        });
    }
    /**
     * Sends a sticker to the current dialog
     */
    sendSticker(id) {
        return this.send({
            sticker_id: id
        });
    }
    /**
     * Sends a photo to the current dialog
     *
     * @param {*[]} sources
     */
    async sendPhoto(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.vk.upload.messagePhoto({
            source
        }))));
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * Sends a document to the current dialog
     *
     * @param {*[]} sources
     */
    async sendDocument(rawSources, params = {}) {
        const sources = !Array.isArray(rawSources)
            ? [rawSources]
            : rawSources;
        const attachment = await Promise.all(sources.map(source => (this.vk.upload.messageDocument({
            peer_id: this.senderId,
            source
        }))));
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * Sends a audio message to the current dialog
     *
     * @param {*}  sourxe
     */
    async sendAudioMessage(source, params = {}) {
        const attachment = await this.vk.upload.audioMessage({
            peer_id: this.senderId,
            source
        });
        const response = await this.send({
            ...params,
            attachment
        });
        return response;
    }
    /**
     * Changes the status of typing in the dialog
     */
    async setActivity() {
        // @ts-ignore
        const isActivited = await this.vk.api.messages.setActivity({
            peer_id: this.peerId,
            type: 'typing'
        });
        return Boolean(isActivited);
    }
    /**
     * Marks messages as important or removes a mark
     */
    async markAsImportant(ids = [this.id], options = { important: Number(!this.isImportant) }) {
        // @ts-ignore
        const messageIds = await this.vk.api.messages.markAsImportant({
            ...options,
            message_ids: ids.join(',')
        });
        if (messageIds.includes(this.id)) {
            this.payload.important = Boolean(options.important);
        }
        return messageIds;
    }
    /**
     * Deletes the message
     */
    async deleteMessage(ids = [this.id], options = { spam: 0 }) {
        // @ts-ignore
        const messageIds = await this.vk.api.messages.delete({
            ...options,
            message_ids: ids.join(',')
        });
        return messageIds;
    }
    /**
     * Restores the message
     */
    async restoreMessage() {
        // @ts-ignore
        const isRestored = await this.vk.api.messages.restore({
            message_id: this.id
        });
        return Boolean(isRestored);
    }
    /**
     * Rename the chat
     */
    async renameChat(title) {
        this.assertIsChat();
        // @ts-ignore
        const isRenamed = await this.vk.api.messages.editChat({
            chat_id: this.chatId,
            title
        });
        return Boolean(isRenamed);
    }
    /**
     * Sets a new image for the chat
     *
     * @param {*}  source
     */
    async newChatPhoto(source, params = {}) {
        this.assertIsChat();
        const response = await this.vk.upload.chatPhoto({
            ...params,
            chat_id: this.chatId,
            source
        });
        return response;
    }
    /**
     * Remove the chat photo
     */
    async deleteChatPhoto() {
        this.assertIsChat();
        // @ts-ignore
        return this.vk.api.messages.deleteChatPhoto({
            chat_id: this.chatId
        });
    }
    /**
     * Invites a new user
     */
    async inviteUser(id = this.eventMemberId) {
        this.assertIsChat();
        // @ts-ignore
        const isInvited = await this.vk.api.messages.addChatUser({
            chat_id: this.chatId,
            user_id: id
        });
        return Boolean(isInvited);
    }
    /**
     * Excludes user
     */
    async kickUser(id = this.eventMemberId) {
        this.assertIsChat();
        // @ts-ignore
        const isKicked = await this.vk.api.messages.removeChatUser({
            chat_id: this.chatId,
            member_id: id
        });
        return Boolean(isKicked);
    }
    /**
     * Pins a message
     */
    async pinMessage() {
        this.assertIsChat();
        // @ts-ignore
        const isPinned = await this.vk.api.messages.pin({
            peer_id: this.peerId,
            message_id: this.id
        });
        return Boolean(isPinned);
    }
    /**
     * Unpins a message
     */
    async unpinMessage() {
        this.assertIsChat();
        // @ts-ignore
        const isUnpinned = await this.vk.api.messages.unpin({
            peer_id: this.peerId,
            message_id: this.id
        });
        return Boolean(isUnpinned);
    }
    /**
     * Applies the payload
     */
    applyPayload(payload) {
        this.payload = payload;
        this.text = payload.text
            ? unescapeHTML(payload.text)
            : null;
    }
    /**
     * Checks that in a chat
     */
    assertIsChat() {
        if (!this.isChat) {
            throw new VKError({
                message: 'This method is only available in chat',
                code: 'IS_NOT_CHAT'
            });
        }
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const beforeAttachments = [];
        if (this.isEvent) {
            beforeAttachments.push('eventType', 'eventMemberId', 'eventText', 'eventEmail');
        }
        if (this.hasReplyMessage) {
            beforeAttachments.push('replyMessage');
        }
        const afterAttachments = [];
        if (this.hasMessagePayload) {
            afterAttachments.push('messagePayload');
        }
        afterAttachments.push('isOutbox');
        if (this.$match) {
            afterAttachments.push('$match');
        }
        return copyParams(this, [
            'id',
            'conversationMessageId',
            'peerId',
            'peerType',
            'senderId',
            'senderType',
            'createdAt',
            'text',
            ...beforeAttachments,
            'forwards',
            'attachments',
            ...afterAttachments
        ]);
    }
}

const subTypes = {
    wall_post_new: 'new_wall_post',
    wall_repost: 'new_wall_repost'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class WallPostContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'wall_post',
            subTypes: [
                subTypes[options.updateType]
            ]
        });
        // @ts-ignore
        this.wall = new WallAttachment(this.payload, this.vk);
    }
    /**
     * Checks is repost
     */
    get isRepost() {
        return this.subTypes.includes('new_wall_repost');
    }
    /**
     * Removes a record from the wall
     */
    deletePost() {
        const { wall } = this;
        // @ts-ignore
        return this.vk.api.wall.delete({
            post_id: wall.id,
            owner_id: wall.ownerId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'wall',
            'isRepost'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class StreamingContext extends Context {
    constructor(options) {
        const { action, event_type: type } = options.payload;
        super({
            ...options,
            type: 'publication',
            subTypes: [
                `publication_${type}`,
                `${action}_publication`,
                `${action}_publication_${type}`
            ]
        });
        this.attachments = transformAttachments(this.payload.attachments, this.vk);
    }
    /**
     * Checks is new object
     */
    get isNew() {
        return this.actionType === 'new';
    }
    /**
     * Checks is update object
     */
    get isUpdate() {
        return this.actionType === 'update';
    }
    /**
     * Checks is delete object
     */
    get isDelete() {
        return this.actionType === 'delete';
    }
    /**
     * Checks is restore object
     */
    get isRestore() {
        return this.actionType === 'restore';
    }
    /**
     * Checks is post event
     */
    get isPost() {
        return this.eventType === 'post';
    }
    /**
     * Checks is share event
     */
    get isShare() {
        return this.eventType === 'share';
    }
    /**
     * Checks is comment event
     */
    get isComment() {
        return this.eventType === 'comment';
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Returns the event URL
     */
    get url() {
        return this.payload.event_url;
    }
    /**
     * Returns the creation time
     */
    get createdAt() {
        return this.payload.creation_time;
    }
    /**
     * Returns the text of the post
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the text of the shared post
     */
    get sharedText() {
        return this.payload.shared_post_text || null;
    }
    /**
     * Returns the creation time from original post
     */
    get sharedAt() {
        return this.payload.shared_post_creation_time || null;
    }
    /**
     * Returns the action type
     */
    get actionType() {
        return this.payload.action;
    }
    /**
     * Returns the event type
     */
    get eventType() {
        return this.payload.event_type;
    }
    /**
     * Returns the creation time from
     */
    get actionAt() {
        return this.payload.action_time;
    }
    /**
     * Returns the geo location
     */
    get geo() {
        return this.payload.geo;
    }
    /**
     * Returns the rule tags
     */
    get tags() {
        return this.payload.tags;
    }
    /**
     * Returns the identifier signer user
     */
    get signerId() {
        return this.payload.signer_id;
    }
    /**
     * Returns the information of author
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get author() {
        return this.payload.author;
    }
    /**
     * Returns the identifier author
     */
    get authorId() {
        return this.payload.author.id;
    }
    /**
     * Returns the author url
     */
    get authorUrl() {
        return this.payload.author.author_url;
    }
    /**
     * Returns the identifier of the author of the original post
     */
    get sharedAuthorId() {
        return this.payload.author.shared_post_author_id || null;
    }
    /**
     * Returns the author url of the original post
     */
    get sharedAuthorUrl() {
        return this.payload.author.shared_post_author_url || null;
    }
    /**
     * Returns the author platform
     */
    get authorPlatform() {
        return platforms.get(this.payload.author.platform);
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const properties = [
            'url',
            'created',
            'text',
            'sharedText',
            'sharedAt',
            'actionType',
            'eventType',
            'actionAt',
            'geo',
            'tags',
            'signerId',
            'author',
            'authorId',
            'authorUrl',
            'sharedAuthorId',
            'sharedAuthorUrl',
            'authorPlatform',
            'isNew',
            'isUpdate',
            'isDelete',
            'isRestore',
            'isPost',
            'isShare',
            'isComment'
        ];
        const filtredEmptyProperties = properties.filter(property => (this[property] !== null));
        // @ts-ignore
        return copyParams(this, filtredEmptyProperties);
    }
}

/**
 * Causes of blocking
 */
const reasonNames = new Map([
    [0, 'other'],
    [1, 'spam'],
    [2, 'members_insult'],
    [3, 'obscene_expressions'],
    [4, 'messages_off_topic']
]);
const subTypes$1 = {
    user_block: 'block_group_user',
    user_unblock: 'unblock_group_user'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupUserContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_user',
            subTypes: [
                subTypes$1[options.updateType]
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isBlocked() {
        return this.subTypes.includes('block_group_user');
    }
    /**
     * Checks is leave user
     */
    get isUnblocked() {
        return this.subTypes.includes('unblock_group_user');
    }
    /**
     * Checks that the block has expired
     *
     * @return {?boolean}
     */
    get isExpired() {
        if (this.isBlocked) {
            return null;
        }
        return Boolean(this.payload.by_end_date);
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the reason for the ban
     */
    get reasonId() {
        return this.payload.reason || null;
    }
    /**
     * Returns the reason name for the ban
     */
    get reasonName() {
        return reasonNames.get(this.reasonId);
    }
    /**
     * Returns the unblock date or null if permanent
     */
    get unblockAt() {
        return this.payload.unblock_date || null;
    }
    /**
     * Returns the administrator comment to block
     */
    get comment() {
        return this.payload.comment || null;
    }
    /**
     * Adds a user to the community blacklist
     */
    ban(params) {
        if (this.isBlocked) {
            return Promise.reject(new VKError({
                message: 'User is blocked',
                code: 'ALREADY_BANNED'
            }));
        }
        // @ts-ignore
        return this.vk.api.groups.ban({
            ...params,
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Adds a user to the community blacklist
     *
     * @return {Promise}
     */
    unban() {
        if (this.isUnblocked) {
            return Promise.reject(new VKError({
                message: 'User is not blocked',
                code: 'ALREADY_UNBANNED'
            }));
        }
        // @ts-ignore
        return this.vk.api.groups.unban({
            group_id: this.$groupId,
            user_id: this.userId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'adminId',
            'userId',
            'reasonId',
            'reasonName',
            'comment',
            'isExpired',
            'isBlocked',
            'isUnblocked'
        ]);
    }
}

const subTypes$2 = {
    8: 'user_online',
    9: 'user_offline'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VoteContext$1 extends Context {
    constructor(options) {
        const [eventId, userId, extra, date] = options.payload;
        super({
            ...options,
            type: 'user_active',
            subTypes: [
                subTypes$2[eventId]
            ],
            payload: {
                user_id: -userId,
                extra,
                date
            }
        });
    }
    /**
     * Checks that the user is online
     */
    get isUserOnline() {
        return this.subTypes.includes('user_online');
    }
    /**
     * Checks that the user is online
     */
    get isUserOffline() {
        return this.subTypes.includes('user_offline');
    }
    /**
     * Checks that the user has logged out of the network himself
     */
    get isSelfExit() {
        return this.isUserOffline && !this.payload.extra;
    }
    /**
     * Checks that the user logged out a timeout
     */
    get isTimeoutExit() {
        return this.isUserOffline && Boolean(this.payload.extra);
    }
    /**
     * Returns the user id
     */
    get userId() {
        return this.payload.user_id || null;
    }
    /**
     * Returns the date when this event was created
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the name of the platform from which the user entered
     */
    get platformName() {
        return platforms.get(this.payload.extra);
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'createdAt',
            'platformName',
            'isSelfExit',
            'isTimeoutExit',
            'isUserOnline',
            'isUserOffline'
        ]);
    }
}

const subTypes$3 = {
    10: 'remove_dialog_flags',
    11: 'update_dialog_flags',
    12: 'set_dialog_flags'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class DialogFlagsContext extends Context {
    constructor(options) {
        const [eventId, peerId, flags] = options.payload;
        super({
            ...options,
            type: 'dialog_flags',
            subTypes: [
                subTypes$3[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags
            }
        });
    }
    /**
     * Checks that an important dialogue
     */
    get isImportant() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 1);
    }
    /**
     * Checks that the unanswered dialog
     */
    get isUnanswered() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 2);
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    /**
     * Marks the conversation as answered or unchecked
     */
    markAsAnsweredConversation(params) {
        // @ts-ignore
        return this.vk.api.messages.markAsAnsweredConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Marks the conversation as important or removes the mark
     */
    markAsImportantConversation(params) {
        // @ts-ignore
        return this.vk.api.messages.markAsImportantConversation({
            ...params,
            peer_id: this.peerId
        });
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'peerId',
            'flags',
            'isImportant',
            'isUnanswered'
        ]);
    }
}

const subTypes$4 = {
    group_change_photo: 'group_update_photo',
    group_update_officers: 'group_update_officers',
    group_change_settings: 'group_update_settings'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupUpdateContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_update',
            subTypes: [
                subTypes$4[options.updateType]
            ]
        });
        this.attachments = options.updateType === 'group_change_photo'
            // @ts-ignore
            ? [new PhotoAttachment(this.payload.photo, this.vk)]
            : [];
    }
    /**
     * Checks is change photo
     */
    get isChangePhoto() {
        return this.subTypes.includes('group_update_photo');
    }
    /**
     * Checks is change officers
     */
    get isChangeOfficers() {
        return this.subTypes.includes('group_update_officers');
    }
    /**
     * Checks is change settings
     */
    get isChangeSettings() {
        return this.subTypes.includes('group_update_settings');
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Returns the identifier admin
     */
    get adminId() {
        return this.payload.admin_id || null;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the old level permission
     */
    get oldLevel() {
        return this.payload.level_old || null;
    }
    /**
     * Returns the new level permission
     */
    get newLevel() {
        return this.payload.level_new || null;
    }
    /**
     * Returns the changes settings
     */
    get changes() {
        return this.payload.changes || null;
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'adminId',
            'userId',
            'oldLevel',
            'newLevel',
            'changes',
            'attachments'
        ]);
    }
}

const subTypes$5 = {
    group_leave: 'leave_group_member',
    group_join: 'join_group_member'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class GroupMemberContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'group_member',
            subTypes: [
                subTypes$5[options.updateType]
            ]
        });
    }
    /**
     * Checks is join user
     */
    get isJoin() {
        return this.subTypes.includes('join_group_member');
    }
    /**
     * Checks is leave user
     */
    get isLeave() {
        return this.subTypes.includes('leave_group_member');
    }
    /**
     * Checks is self leave user
     */
    get isSelfLeave() {
        if (this.isJoin) {
            return null;
        }
        return Boolean(this.payload.self);
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the join type
     */
    get joinType() {
        if (this.isLeave) {
            return null;
        }
        return this.payload.join_type;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'joinType',
            'isJoin',
            'isLeave',
            'isSelfLeave'
        ]);
    }
}

const subTypes$6 = {
    message_allow: 'message_subscribe',
    message_deny: 'message_unsubscribe'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageAllowContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'message_subscribers',
            subTypes: [
                subTypes$6[options.updateType]
            ]
        });
    }
    /**
     * Checks that the user has subscribed to messages
     */
    get isSubscribed() {
        return this.subTypes.includes('message_subscribe');
    }
    /**
     * Checks that the user has unsubscribed from the messages
     */
    get isUbsubscribed() {
        return this.subTypes.includes('message_unsubscribe');
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the key
     */
    get key() {
        return this.payload.key || null;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'key',
            'isSubscribed',
            'isUbsubscribed'
        ]);
    }
}

const subTypes$7 = {
    6: 'read_inbox_messages',
    7: 'read_outbox_messages'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class ReadMessagesContext extends Context {
    constructor(options) {
        const [eventId, peerId, id] = options.payload;
        super({
            ...options,
            type: 'read_messages',
            subTypes: [
                subTypes$7[eventId]
            ],
            payload: {
                peer_id: peerId,
                id
            }
        });
    }
    /**
     * Checks that inbox messages are read
     */
    get isInbox() {
        return this.subTypes.includes('read_inbox_messages');
    }
    /**
     * Checks that outbox messages are read
     */
    get isOutbox() {
        return this.subTypes.includes('read_outbox_messages');
    }
    /**
     * Returns the ID before the message read
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the peer ID
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'isInbox',
            'isOutbox'
        ]);
    }
}

const subTypes$8 = {
    1: 'update_message_flags',
    2: 'set_message_flags',
    3: 'remove_message_flags'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MessageFlagsContext extends Context {
    constructor(options) {
        const [eventId, id, flags, peerId] = options.payload;
        super({
            ...options,
            type: 'message_flags',
            subTypes: [
                subTypes$8[eventId]
            ],
            payload: {
                peer_id: peerId,
                flags,
                id
            }
        });
    }
    /**
     * Verifies that the message is not read
     */
    get isUnread() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 1);
    }
    /**
     * Checks that the outgoing message
     */
    get isOutbox() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 2);
    }
    /**
     * Verifies that a reply has been created to the message
     */
    get isReplied() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 4);
    }
    /**
     * Verifies that the marked message
     */
    get isImportant() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 8);
    }
    /**
     * Verifies that the message was sent via chat
     */
    get isChat() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 16);
    }
    /**
     * Verifies that the message was sent by a friend
     */
    get isFriends() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 32);
    }
    /**
     * Verifies that the message is marked as "Spam"
     */
    get isSpam() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 64);
    }
    /**
     * Verifies that the message has been deleted (in the Recycle Bin)
     */
    get isDeleted() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 128);
    }
    /**
     * Verifies that the message was verified by the user for spam
     */
    get isFixed() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 256);
    }
    /**
     * Verifies that the message contains media content
     */
    get isMedia() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 512);
    }
    /**
     * Checks that a welcome message from the community
     */
    get isHidden() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 65536);
    }
    /**
     * Message deleted for all recipients
     */
    get isDeletedForAll() {
        // eslint-disable-next-line no-bitwise
        return Boolean(this.flags & 131072);
    }
    /**
     * Returns the message ID
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the destination identifier
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the values of the flags
     */
    get flags() {
        return this.payload.flags;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'flags'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VKAppPayloadContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_app_event',
            subTypes: ['vk_app_payload']
        });
    }
    /**
     * Returns the identifier of the user whose action the event was sent to in the application
     */
    get userId() {
        return this.payload.user_id;
    }
    /**
     * Returns the identifier of the application from which the event was sent
     */
    get appId() {
        return this.payload.app_id;
    }
    /**
     * Returns the identifier of the community to which the notification was sent
     */
    get groupId() {
        return this.payload.group_id;
    }
    /**
     * Returns the transferred useful data
     */
    get eventPayload() {
        return this.payload.payload;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'userId',
            'appId',
            'groupId',
            'eventPayload'
        ]);
    }
}

/**
 * Find types
 *
 * ```
 * wall_reply_new
 * ```
 */
const findTypes = /([^_]+)_([^_]+)_([^_]+)/;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class CommentActionContext extends Context {
    constructor(options) {
        const { 1: initiator, 3: action } = options.updateType.match(findTypes);
        super({
            ...options,
            type: 'comment',
            subTypes: [
                `${initiator}_comment`,
                `${action}_${initiator}_comment`
            ]
        });
        this.attachments = transformAttachments(this.payload.attachments, this.vk);
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Checks is new comment
     */
    get isNew() {
        return this.includesFromSubType('new');
    }
    /**
     * Checks is edit comment
     */
    get isEdit() {
        return this.includesFromSubType('edit');
    }
    /**
     * Checks is delete comment
     */
    get isDelete() {
        return this.includesFromSubType('delete');
    }
    /**
     * Checks is restore comment
     */
    get isRestore() {
        return this.includesFromSubType('restore');
    }
    /**
     * Checks is photo comment
     */
    get isPhotoComment() {
        return this.includesFromSubType('photo');
    }
    /**
     * Checks is wall comment
     */
    get isWallComment() {
        return this.includesFromSubType('wall');
    }
    /**
     * Checks is video comment
     */
    get isVideoComment() {
        return this.includesFromSubType('video');
    }
    /**
     * Checks is board comment
     */
    get isBoardComment() {
        return this.includesFromSubType('board');
    }
    /**
     * Checks is board comment
     */
    get isMarketComment() {
        return this.includesFromSubType('market');
    }
    /**
     * Checks is reply comment
     */
    get isReply() {
        return 'reply_to_comment' in this.payload;
    }
    /**
     * Returns the identifier comment
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the identifier reply comment
     */
    get replyId() {
        return this.payload.reply_to_comment || null;
    }
    /**
     * Returns the identifier user
     */
    get userId() {
        return (this.payload.from_id
            || this.payload.user_id
            || null);
    }
    /**
     * Returns the identifier reply user
     */
    get replyUserId() {
        return this.payload.reply_to_user || null;
    }
    /**
     * Returns the identifier of the user who deleted the comment
     */
    get removerUserId() {
        return this.payload.deleter_id || null;
    }
    /**
     * Returns the identifier of object
     */
    get objectId() {
        const { payload } = this;
        return (payload.photo_id
            || payload.video_id
            || payload.post_id
            || payload.topic_id
            || payload.item_id
            || null);
    }
    /**
     * Returns the identifier of owner
     */
    get ownerId() {
        const { payload } = this;
        return (payload.owner_id
            || payload.photo_owner_id
            || payload.video_owner_id
            || payload.post_owner_id
            || payload.topic_owner_id
            || payload.market_owner_id
            || null);
    }
    /**
     * Returns the date creation action comment
     */
    get createdAt() {
        return this.payload.date || null;
    }
    /**
     * Returns the text comment
     */
    get text() {
        return this.payload.text || null;
    }
    /**
     * Returns the likes
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    get likes() {
        return this.payload.likes || null;
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Includes from subtype
     */
    includesFromSubType(type) {
        return this.subTypes[1].includes(type);
    }
    /**
     * Edits a comment
     */
    editComment(options) {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            // @ts-ignore
            return this.vk.api.board.editComment({
                ...options,
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            ...options,
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            // @ts-ignore
            return this.vk.api.photos.editComment(params);
        }
        if (this.isVideoComment) {
            // @ts-ignore
            return this.vk.api.video.editComment(params);
        }
        if (this.isWallComment) {
            // @ts-ignore
            return this.vk.api.wall.editComment(params);
        }
        if (this.isMarketComment) {
            // @ts-ignore
            return this.vk.api.market.editComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for editing comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Removes comment
     */
    deleteComment() {
        if (this.isDelete) {
            return Promise.reject(new VKError({
                message: 'Comment is deleted',
                code: 'ALREADY_DELETED'
            }));
        }
        if (this.isBoardComment) {
            // @ts-ignore
            return this.vk.api.board.deleteComment({
                comment_id: this.id,
                topic_id: this.objectId,
                group_id: this.$groupId
            });
        }
        const params = {
            comment_id: this.id,
            owner_id: this.ownerId
        };
        if (this.isPhotoComment) {
            // @ts-ignore
            return this.vk.api.photos.deleteComment(params);
        }
        if (this.isVideoComment) {
            // @ts-ignore
            return this.vk.api.video.deleteComment(params);
        }
        if (this.isWallComment) {
            // @ts-ignore
            return this.vk.api.wall.deleteComment(params);
        }
        if (this.isMarketComment) {
            // @ts-ignore
            return this.vk.api.market.deleteComment(params);
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting comment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        const properties = [
            'id',
            'replyId',
            'userId',
            'replyUserId',
            'removerUserId',
            'objectId',
            'ownerId',
            'createdAt',
            'text',
            'likes',
            'attachments',
            'isReply'
        ];
        const filtredEmptyProperties = properties.filter(property => (this[property] !== null));
        // @ts-ignore
        return copyParams(this, filtredEmptyProperties);
    }
}

const subTypes$9 = {
    photo_new: ['new_photo_attachment', PhotoAttachment],
    video_new: ['new_video_attachment', VideoAttachment],
    audio_new: ['new_audio_attachment', AudioAttachment]
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class NewAttachmentsContext extends Context {
    constructor(options) {
        const [subType, PayloadAttachment] = subTypes$9[options.updateType];
        super({
            ...options,
            type: 'new_attachment',
            subTypes: [
                subType
            ]
        });
        this.attachments = [new PayloadAttachment(this.payload, this.vk)];
    }
    /**
     * Checks is attachment photo
     */
    get isPhoto() {
        return this.subTypes.includes('new_photo_attachment');
    }
    /**
     * Checks is attachment video
     */
    get isVideo() {
        return this.subTypes.includes('new_video_attachment');
    }
    /**
     * Checks is attachment audio
     */
    get isAudio() {
        return this.subTypes.includes('new_audio_attachment');
    }
    /**
     * Checks for the presence of attachments
     */
    hasAttachments(type = null) {
        if (type === null) {
            return this.attachments.length > 0;
        }
        return this.attachments.some(attachment => (attachment.type === type));
    }
    /**
     * Returns the attachments
     */
    getAttachments(type = null) {
        if (type === null) {
            return this.attachments;
        }
        return this.attachments.filter(attachment => (attachment.type === type));
    }
    /**
     * Removes the attachment
     */
    deleteAttachment() {
        if (this.isPhoto) {
            const [photo] = this.getAttachments('photo');
            // @ts-ignore
            return this.vk.api.photos.delete({
                owner_id: photo.ownerId,
                photo_id: photo.id
            });
        }
        if (this.isVideo) {
            const [video] = this.getAttachments('video');
            // @ts-ignore
            return this.vk.api.video.delete({
                owner_id: video.ownerId,
                video_id: video.id
            });
        }
        if (this.isAudio) {
            const [audio] = this.getAttachments('audio');
            // @ts-ignore
            return this.vk.api.audio.delete({
                owner_id: audio.ownerId,
                audio_id: audio.id
            });
        }
        return Promise.reject(new VKError({
            message: 'Unsupported event for deleting attachment',
            code: 'UNSUPPORTED_EVENT'
        }));
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'attachments',
            'isPhoto',
            'isVideo',
            'isAudio'
        ]);
    }
}

const subTypes$a = {
    13: 'delete_messages',
    14: 'restore_messages'
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class RemovedMessagesContext extends Context {
    constructor(options) {
        const [eventId, peerId, id] = options.payload;
        super({
            ...options,
            type: 'removed_messages',
            subTypes: [
                subTypes$a[eventId]
            ],
            payload: {
                peer_id: peerId,
                id
            }
        });
    }
    /**
     * Checks that messages have been deleted
     */
    get isRemoved() {
        return this.subTypes.includes('delete_messages');
    }
    /**
     * Checks that messages have been restored
     */
    get isRecovery() {
        return this.subTypes.includes('restore_messages');
    }
    /**
     * Returns the identifier of the message
     */
    get id() {
        return this.payload.id;
    }
    /**
     * Returns the peer ID
     */
    get peerId() {
        return this.payload.peer_id;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'id',
            'peerId',
            'isRemoved',
            'isRecovery'
        ]);
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class VKPayTransactionContext extends Context {
    constructor(options) {
        super({
            ...options,
            type: 'vk_pay_transaction',
            subTypes: ['vk_pay_transfer']
        });
    }
    /**
     * Returns the identifier transfer sender
     */
    get fromId() {
        return this.payload.from_id;
    }
    /**
     * Returns the transfer amount in thousandths of a ruble
     */
    get amount() {
        return this.payload.amount;
    }
    /**
     * Returns the description on the translation
     */
    get description() {
        return this.payload.description;
    }
    /**
     * Returns the unixtime transfer time
     */
    get createdAt() {
        return this.payload.date;
    }
    /**
     * Returns the custom data
     */
    [inspectCustomData]() {
        return copyParams(this, [
            'fromId',
            'amount',
            'description',
            'createdAt'
        ]);
    }
}

const { NEED_RESTART, POLLING_REQUEST_FAILED } = updatesErrors;
const debug$8 = createDebug('vk-io:updates');
/**
 * Version polling
 */
const POLLING_VERSION = '3';
class PollingTransport {
    constructor(vk) {
        this.started = false;
        /**
         * 2 -  Attachments
         * 8 -  Extended events
         * 64 - Online user platform ID
         */
        // eslint-disable-next-line no-bitwise
        this.mode = 2 | 8 | 64;
        this.ts = 0;
        this.pts = 0;
        this.restarted = 0;
        this.vk = vk;
    }
    async start() {
        if (this.started) {
            throw new Error('Polling updates already started');
        }
        if (!this.pollingHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const { pollingGroupId } = this.vk.options;
            const isGroup = pollingGroupId !== null;
            const { server, key, ts } = isGroup
                // @ts-ignore
                ? await this.vk.api.groups.getLongPollServer({
                    group_id: pollingGroupId
                })
                // @ts-ignore
                : await this.vk.api.messages.getLongPollServer({
                    lp_version: POLLING_VERSION
                });
            if (this.ts === 0) {
                this.ts = ts;
            }
            const pollingURL = isGroup
                ? server
                : `https://${server}`;
            this.url = new URL(pollingURL);
            this.url.search = String(new URLSearchParams({
                key,
                act: 'a_check',
                wait: '25',
                mode: String(this.mode),
                version: POLLING_VERSION
            }));
            this.startFetchLoop();
            debug$8(`${isGroup ? 'Bot' : 'User'} Polling started`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        this.restarted = 0;
    }
    /**
     * Starts forever fetch updates  loop
     */
    async startFetchLoop() {
        try {
            while (this.started) {
                await this.fetchUpdates();
            }
        }
        catch (error) {
            debug$8('longpoll error', error);
            const { pollingWait, pollingAttempts } = this.vk.options;
            if (error.code !== NEED_RESTART && this.restarted < pollingAttempts) {
                this.restarted += 1;
                debug$8('longpoll restart request');
                await delay(3e3);
                this.startFetchLoop();
                return;
            }
            while (this.started) {
                try {
                    await this.stop();
                    await this.start();
                    break;
                }
                catch (restartError) {
                    debug$8('longpoll restarted error', restartError);
                    this.started = true;
                    await delay(pollingWait);
                }
            }
        }
    }
    /**
     * Gets updates
     */
    async fetchUpdates() {
        this.url.searchParams.set('ts', String(this.ts));
        debug$8('http -->');
        let response = await fetch(this.url, {
            agent: this.vk.options.agent,
            method: 'GET',
            timeout: 30e3,
            compress: false,
            headers: {
                connection: 'keep-alive'
            }
        });
        debug$8(`http <-- ${response.status}`);
        if (!response.ok) {
            throw new UpdatesError({
                code: POLLING_REQUEST_FAILED,
                message: 'Polling request failed'
            });
        }
        response = await response.json();
        if ('failed' in response) {
            if (response.failed === 1) {
                this.ts = response.ts;
                return;
            }
            this.ts = 0;
            throw new UpdatesError({
                code: NEED_RESTART,
                message: 'The server has failed'
            });
        }
        this.restarted = 0;
        this.ts = response.ts;
        if ('pts' in response) {
            this.pts = Number(response.pts);
        }
        /* Async handle updates */
        response.updates.forEach(async (update) => {
            try {
                await this.pollingHandler(update);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.error('Handle polling update error:', error);
            }
        });
    }
    subscribe(handler) {
        this.pollingHandler = handler;
    }
}

const splitPath = (path) => (path
    .replace(/\[([^[\]]*)\]/g, '.$1.')
    .split('.')
    .filter(Boolean));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getObjectValue = (source, selectors) => {
    let link = source;
    for (const selector of selectors) {
        if (!link[selector]) {
            return undefined;
        }
        link = link[selector];
    }
    return link;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const unifyCondition = (condition) => {
    if (typeof condition === 'function') {
        return condition;
    }
    if (condition instanceof RegExp) {
        return (text) => (condition.test(text));
    }
    if (Array.isArray(condition)) {
        const arrayConditions = condition.map(unifyCondition);
        return (value) => (Array.isArray(value)
            ? arrayConditions.every((cond) => (value.some((val) => cond(val))))
            : arrayConditions.some((cond) => (cond(value))));
    }
    return (value) => value === condition;
};
const parseRequestJSON = (req, res) => (new Promise((resolve, reject) => {
    let body = '';
    req.on('error', reject);
    req.on('data', (chunk) => {
        if (body.length > 1e6) {
            body = null;
            res.writeHead(413);
            res.end();
            req.connection.destroy();
            reject();
            return;
        }
        body += String(chunk);
    });
    req.on('end', () => {
        try {
            const json = JSON.parse(body);
            resolve(json);
        }
        catch (e) {
            reject(e);
        }
    });
}));

const debug$9 = createDebug('vk-io:updates');
class WebhookTransport {
    constructor(vk) {
        this.started = false;
        this.webhookServer = null;
        this.vk = vk;
    }
    /**
     * Starts the webhook server
     */
    async start({ path = '/', tls, host, port } = {}, next) {
        if (this.started) {
            throw new Error('Webhook updates already started');
        }
        if (!this.webhookHandler) {
            throw new Error('You didn\'t subscribe to updates');
        }
        this.started = true;
        try {
            const webhookCallback = this.getWebhookCallback(path);
            const callback = typeof next === 'function'
                ? (req, res) => (webhookCallback(req, res, () => (next(req, res))))
                : (req, res) => (webhookCallback(req, res, () => {
                    res.writeHead(403);
                    res.end();
                }));
            this.webhookServer = tls
                ? createServer(tls, callback)
                : createServer$1(callback);
            const { webhookServer } = this;
            const listen = promisify(webhookServer.listen).bind(webhookServer);
            const serverPort = port || (tls
                ? 443
                : 80);
            await listen(serverPort, host);
            debug$9(`Webhook listening on port: ${serverPort}`);
        }
        catch (error) {
            this.started = false;
            throw error;
        }
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        this.started = false;
        if (this.webhookServer !== null) {
            const { webhookServer } = this;
            const close = promisify(webhookServer.close).bind(webhookServer);
            await close();
            this.webhookServer = null;
        }
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path = null) {
        const headers = {
            connection: 'keep-alive',
            'content-type': 'text/plain'
        };
        const checkIsNotValidPath = path !== null
            ? (requestPath) => requestPath !== path
            : () => false;
        return async (req, res, next) => {
            if (req.method !== 'POST' || checkIsNotValidPath(req.url)) {
                next();
                return;
            }
            let update;
            try {
                update = typeof req.body !== 'object'
                    ? await parseRequestJSON(req, res)
                    : req.body;
            }
            catch (e) {
                debug$9(e);
                return;
            }
            try {
                const { webhookSecret, webhookConfirmation } = this.vk.options;
                if (webhookSecret !== null && update.secret !== webhookSecret) {
                    res.writeHead(403);
                    res.end();
                    return;
                }
                if (update.type === 'confirmation') {
                    if (webhookConfirmation === null) {
                        res.writeHead(500);
                        res.end();
                        return;
                    }
                    res.writeHead(200, headers);
                    res.end(String(webhookConfirmation));
                    return;
                }
                res.writeHead(200, headers);
                res.end('ok');
                this.webhookHandler(update).catch((error) => {
                    // eslint-disable-next-line no-console
                    console.error('Handle webhook update error', error);
                });
            }
            catch (error) {
                debug$9('webhook error', error);
                res.writeHead(415);
                res.end();
            }
        };
    }
    subscribe(handler) {
        this.webhookHandler = handler;
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        return async (context) => {
            const update = context.request.body;
            const { webhookSecret, webhookConfirmation } = this.vk.options;
            if (webhookSecret !== null && update.secret !== webhookSecret) {
                context.status = 403;
                return;
            }
            if (update.type === 'confirmation') {
                if (webhookConfirmation === null) {
                    context.status = 500;
                    return;
                }
                context.body = webhookConfirmation;
                return;
            }
            context.body = 'ok';
            context.set('connection', 'keep-alive');
            /* Do not delay server response */
            this.webhookHandler(update).catch((error) => {
                // eslint-disable-next-line no-console
                console.error('Handle webhook update error', error);
            });
        };
    }
}

const debug$a = createDebug('vk-io:updates');
const webhookContextsEvents = [
    [
        ['message_new', 'message_edit', 'message_reply'],
        MessageContext
    ],
    [
        ['message_allow', 'message_deny'],
        MessageAllowContext
    ],
    [
        ['photo_new', 'audio_new', 'video_new'],
        NewAttachmentsContext
    ],
    [
        ['wall_post_new', 'wall_repost'],
        WallPostContext
    ],
    [
        ['group_join', 'group_leave'],
        GroupMemberContext
    ],
    [
        ['user_block', 'user_unblock'],
        GroupUserContext
    ],
    [
        [
            'photo_comment_new',
            'photo_comment_edit',
            'photo_comment_delete',
            'photo_comment_restore',
            'video_comment_new',
            'video_comment_edit',
            'video_comment_delete',
            'video_comment_restore',
            'wall_reply_new',
            'wall_reply_edit',
            'wall_reply_delete',
            'wall_reply_restore',
            'board_post_new',
            'board_post_edit',
            'board_post_delete',
            'board_post_restore',
            'market_comment_new',
            'market_comment_edit',
            'market_comment_delete',
            'market_comment_restore'
        ],
        CommentActionContext
    ],
    [
        ['poll_vote_new'],
        VoteContext
    ],
    [
        ['group_change_photo', 'group_officers_edit', 'group_change_settings'],
        GroupUpdateContext
    ],
    [
        ['message_typing_state'],
        TypingContext
    ],
    [
        ['app_payload'],
        VKAppPayloadContext
    ],
    [
        ['vkpay_transaction'],
        VKPayTransactionContext
    ]
];
const pollingContextsEvents = [
    [
        [1, 2, 3],
        MessageFlagsContext
    ],
    [
        [4, 5],
        MessageContext
    ],
    [
        [6, 7],
        ReadMessagesContext
    ],
    [
        [8, 9],
        VoteContext$1
    ],
    [
        [10, 11, 12],
        DialogFlagsContext
    ],
    [
        [13, 14],
        RemovedMessagesContext
    ],
    [
        [61, 62],
        TypingContext
    ]
];
const makeContexts = (groups) => {
    const contexts = {};
    for (const [events, UpdateContext] of groups) {
        for (const event of events) {
            contexts[event] = UpdateContext;
        }
    }
    return contexts;
};
// @ts-ignore
const webhookContexts = makeContexts(webhookContextsEvents);
// @ts-ignore
const pollingContexts = makeContexts(pollingContextsEvents);
class Updates {
    /**
     * Constructor
     */
    constructor(vk) {
        this.stack = [];
        this.hearStack = [];
        this.hearFallbackHandler = (context, next) => next();
        this.vk = vk;
        this.reloadMiddleware();
        this.pollingTransport = new PollingTransport(vk);
        this.webhookTransport = new WebhookTransport(vk);
        this.webhookTransport.subscribe(this.handleWebhookUpdate.bind(this));
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Updates';
    }
    /**
     * Checks is started
     */
    get isStarted() {
        return this.pollingTransport.started || this.webhookTransport.started;
    }
    /**
     * Added middleware
     */
    use(middleware) {
        if (typeof middleware !== 'function') {
            throw new TypeError('Middleware must be a function');
        }
        this.stack.push(middleware);
        this.reloadMiddleware();
        return this;
    }
    on(rawEvents, handler) {
        const events = !Array.isArray(rawEvents)
            ? [rawEvents]
            : rawEvents;
        const hasEvents = events.every(Boolean);
        if (!hasEvents) {
            throw new Error('Events should be not empty');
        }
        if (typeof handler !== 'function') {
            throw new TypeError('Handler must be a function');
        }
        return this.use((context, next) => (context.is(events)
            // @ts-ignore
            ? handler(context, next)
            : next()));
    }
    /**
     * Listen by context condition
     */
    hear(hearConditions, handler) {
        const rawConditions = !Array.isArray(hearConditions)
            ? [hearConditions]
            : hearConditions;
        const hasConditions = rawConditions.every(Boolean);
        if (!hasConditions) {
            throw new Error('Condition should be not empty');
        }
        if (typeof handler !== 'function') {
            throw new TypeError('Handler must be a function');
        }
        let textCondition = false;
        let functionCondtion = false;
        // @ts-ignore
        const conditions = rawConditions.map((condition) => {
            if (typeof condition === 'object' && !(condition instanceof RegExp)) {
                functionCondtion = true;
                const entries = Object.entries(condition).map(([path, value]) => ([splitPath(path), unifyCondition(value)]));
                return (text, context) => (entries.every(([selectors, callback]) => {
                    const value = getObjectValue(context, selectors);
                    return callback(value, context);
                }));
            }
            if (typeof condition === 'function') {
                functionCondtion = true;
                return condition;
            }
            textCondition = true;
            if (condition instanceof RegExp) {
                return (text, context) => {
                    const passed = condition.test(text);
                    if (passed) {
                        context.$match = text.match(condition);
                    }
                    return passed;
                };
            }
            const stringCondition = String(condition);
            return (text) => text === stringCondition;
        });
        const needText = textCondition && functionCondtion === false;
        this.hearStack.push((context, next) => {
            const { text } = context;
            if (needText && text === null) {
                return next();
            }
            const hasSome = conditions.some((condition) => (condition(text, context)));
            return hasSome
                // @ts-ignore
                ? handler(context, next)
                : next();
        });
        this.reloadMiddleware();
        return this;
    }
    /**
     * A handler that is called when handlers are not found
     */
    setHearFallbackHandler(handler) {
        this.hearFallbackHandler = handler;
        return this;
    }
    /**
     * Handles longpoll event
     */
    handlePollingUpdate(update) {
        debug$a('longpoll update', update);
        const { 0: type } = update;
        const UpdateContext = pollingContexts[type];
        if (!Context) {
            debug$a(`Unsupported polling context type ${type}`);
            return Promise.resolve();
        }
        // @ts-ignore
        return this.dispatchMiddleware(new UpdateContext({
            vk: this.vk,
            paylaod: update,
            updateType: type,
            source: updatesSources.POLLING
        }));
    }
    /**
     * Handles webhook event
     */
    handleWebhookUpdate(update) {
        debug$a('webhook update', update);
        const { type, object: payload, group_id: groupId } = update;
        const UpdateContext = webhookContexts[type];
        if (!Context) {
            debug$a(`Unsupported webhook context type ${type}`);
            return Promise.resolve();
        }
        // @ts-ignore
        return this.dispatchMiddleware(new UpdateContext({
            vk: this.vk,
            payload,
            groupId,
            updateType: type,
            source: updatesSources.WEBHOOK
        }));
    }
    /**
     * Starts to poll server
     */
    startPolling() {
        const { pollingGroupId } = this.vk.options;
        const isGroup = pollingGroupId !== null;
        this.pollingTransport.subscribe(isGroup
            ? this.handleWebhookUpdate.bind(this)
            : this.handlePollingUpdate.bind(this));
        return this.pollingTransport.start();
    }
    /**
     * Starts the webhook server
     */
    async startWebhook(options = {}, next) {
        return this.webhookTransport.start(options, next);
    }
    /**
     * Automatically determines the settings to run
     */
    async start({ webhook } = {}) {
        if (webhook) {
            await this.startWebhook(webhook);
            return;
        }
        if (!this.vk.options.pollingGroupId) {
            try {
                // @ts-ignore
                const [group] = await this.vk.api.groups.getById();
                this.vk.options.pollingGroupId = group.id;
            }
            catch (error) {
                if (error.code !== apiErrors.WRONG_PARAMETER) {
                    throw error;
                }
                debug$a('This is not a group.');
            }
        }
        await this.startPolling();
    }
    /**
     * Stopping gets updates
     */
    async stop() {
        await Promise.all([
            this.pollingTransport.stop(),
            this.webhookTransport.stop()
        ]);
    }
    /**
     * Returns webhook callback like http[s] or express
     */
    getWebhookCallback(path = null) {
        return this.webhookTransport.getWebhookCallback(path);
    }
    /**
     * Returns the middleware for the webhook under koa
     */
    getKoaWebhookMiddleware() {
        return this.webhookTransport.getKoaWebhookMiddleware();
    }
    /**
     * Calls up the middleware chain
     */
    dispatchMiddleware(context) {
        return this.stackMiddleware(context, noopNext);
    }
    /**
     * Reloads middleware
     */
    reloadMiddleware() {
        const stack = [...this.stack];
        if (this.hearStack.length !== 0) {
            stack.push(getOptionalMiddleware((context) => context.type === 'message' && !context.isEvent, compose([
                ...this.hearStack,
                this.hearFallbackHandler
            ])));
        }
        this.stackMiddleware = compose(stack);
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { isStarted, stack } = this;
        const payload = { isStarted, stack };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

const { INVALID_URL, INVALID_RESOURCE, RESOURCE_NOT_FOUND } = snippetsErrors;
const numberRe = /^-?\d+$/;
const hasProtocolRe = /https?:\/\//i;
const isVKUrl = /^(?:https?:\/\/)?(?:m\.)?vk\.com/i;
const isUserMentionRe = /\*|@/;
const systemMentionRe = /\[([^|]+)|([^|\]]+)\]/;
/**
 * Switch resource types
 *
 * @type {Object}
 */
const enumResourceTypes = {
    id: resourceTypes.USER,
    club: resourceTypes.GROUP,
    public: resourceTypes.GROUP,
    app: resourceTypes.APPLICATION
};
/**
 * Remove search param
 *
 * @type {RegExp}
 */
const removeSearchParam = /(\?|&)[^=]+=/;
/**
 * Resolve the attachment resource
 *
 * @param {string} resource
 * @param {RegExp} pattern
 *
 * @return {Object}
 */
const resolveOwnerResource = (resource, pattern) => {
    const { 1: type, 2: owner, 3: id } = resource.match(pattern);
    return {
        id: Number(id),
        owner: Number(owner),
        type: type.toLowerCase().replace(removeSearchParam, '')
    };
};
class ResourceResolver {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
    }
    /**
     * Resolve resource
     */
    async resolve(rawResource) {
        if (!rawResource) {
            throw new SnippetsError({
                code: INVALID_RESOURCE,
                message: 'Resource is required'
            });
        }
        const resource = String(rawResource).trim();
        if (numberRe.test(resource)) {
            return this.resolveNumber(Number(resource));
        }
        const isMention = (isUserMentionRe.test(resource) || systemMentionRe.test(resource));
        if (isMention) {
            return this.resolveMention(resource);
        }
        if (isVKUrl.test(resource)) {
            return this.resolveUrl(resource);
        }
        return this.resolveScreenName(resource);
    }
    /**
     * Resolve number
     */
    resolveNumber(resource) {
        const isGroup = resource < 0;
        const type = isGroup
            ? 'club'
            : 'id';
        return this.resolveScreenName(type + (isGroup
            ? -resource
            : resource));
    }
    /**
     * Resolve resource mention
     */
    resolveMention(resource) {
        if (isUserMentionRe.test(resource)) {
            return this.resolveScreenName(resource.substring(1));
        }
        const { 1: mentionResource } = resource.match(systemMentionRe);
        return this.resolveScreenName(mentionResource);
    }
    /**
     * Resolve resource url
     */
    async resolveUrl(rawResourceUrl) {
        const resourceUrl = !hasProtocolRe.test(rawResourceUrl)
            ? `https://${rawResourceUrl}`
            : rawResourceUrl;
        const { pathname, search } = new URL(resourceUrl);
        if (pathname === '/') {
            throw new SnippetsError({
                code: INVALID_URL,
                message: 'URL should contain path'
            });
        }
        if (parseAttachment.test(search)) {
            return resolveOwnerResource(search, parseAttachment);
        }
        if (parseOwnerResource.test(search)) {
            return resolveOwnerResource(search, parseOwnerResource);
        }
        return this.resolveScreenName(pathname.substring(1));
    }
    /**
     * Resolve screen name
     */
    async resolveScreenName(resource) {
        if (parseAttachment.test(resource)) {
            return resolveOwnerResource(resource, parseAttachment);
        }
        if (parseOwnerResource.test(resource)) {
            return resolveOwnerResource(resource, parseOwnerResource);
        }
        if (parseResource.test(resource)) {
            const { 1: typeResource, 2: id } = resource.match(parseResource);
            let type = typeResource.toLowerCase();
            if (type in enumResourceTypes) {
                type = enumResourceTypes[type];
            }
            return {
                id: Number(id),
                type
            };
        }
        // @ts-ignore
        const response = await this.vk.api.utils.resolveScreenName({
            screen_name: resource
        });
        if (Array.isArray(response)) {
            throw new SnippetsError({
                message: 'Resource not found',
                code: RESOURCE_NOT_FOUND
            });
        }
        const { type, object_id: id } = response;
        if (type === 'page') {
            return {
                id,
                type: resourceTypes.GROUP
            };
        }
        return { id, type };
    }
}

class Snippets {
    /**
     * Constructor
     */
    constructor(vk) {
        this.vk = vk;
        this.resourceResolver = new ResourceResolver(this.vk);
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Snippets';
    }
    /**
     * Defines the type of object (user, community, application, attachment)
     */
    resolveResource(resource) {
        return this.resourceResolver.resolve(resource);
    }
}

const debug$b = createDebug('vk-io:streaming');
class StreamingAPI {
    /**
     * Constructor
     */
    constructor(vk) {
        this.socket = null;
        this.key = null;
        this.endpoint = null;
        this.started = false;
        this.close = null;
        this.vk = vk;
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'StreamingAPI';
    }
    /**
     * Starts websocket
     */
    async startWebSocket() {
        this.started = true;
        try {
            // @ts-ignore
            const { key, endpoint } = await this.vk.api.streaming.getServerUrl();
            this.key = key;
            this.endpoint = new URL(`https://${endpoint}`);
            const search = new URLSearchParams({ key });
            const { agent } = this.vk.options;
            this.socket = new WebSocket(`wss://${endpoint}/stream?${search}`, { agent });
        }
        catch (error) {
            this.started = false;
            throw error;
        }
        const { socket } = this;
        this.close = promisify(socket.close).bind(socket);
        socket.on('message', async (data) => {
            let message;
            try {
                message = JSON.parse(data);
            }
            catch (error) {
                debug$b('JSON parse failed', error);
                return;
            }
            const { code } = message;
            try {
                switch (code) {
                    case 100: {
                        await this.handleEvent(message.event);
                        break;
                    }
                    case 300: {
                        await this.handleServiceMessage(message.service_message);
                        break;
                    }
                    default: {
                        debug$b(`Unsupported message code: ${code}`);
                    }
                }
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.log('Handle event error', error);
            }
        });
        socket.on('error', (error) => {
            debug$b('WebSocket error', error);
        });
    }
    /**
     * Stop all connection
     */
    async stop() {
        if (!this.started) {
            return;
        }
        await this.close();
        this.started = null;
        this.key = null;
        this.socket = null;
        this.endpoint = null;
    }
    /**
     * Processes server messages
     */
    async handleServiceMessage({ service_code: code }) {
        if ([3000, 3001].includes(code)) {
            await this.stop();
            await this.startWebSocket();
        }
    }
    /**
     * Handles events
     */
    handleEvent(event) {
        const context = new StreamingContext({
            vk: this.vk,
            // @ts-ignore
            payload: event
        });
        return this.vk.updates.dispatchMiddleware(context);
    }
    /**
     * Executes the HTTP request for rules
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async fetchRules(method, payload = {}) {
        const { agent } = this.vk.options;
        const url = new URL('/rules', this.endpoint);
        url.searchParams.set('key', this.key);
        let body;
        if (method !== 'GET') {
            body = JSON.stringify(payload);
        }
        let response = await fetch(url, {
            agent,
            method,
            body,
            headers: {
                'content-type': 'application/json'
            }
        });
        response = await response.json();
        if ('error' in response) {
            throw new StreamingRuleError(response.error);
        }
        return response;
    }
    /**
     * Returns a list of rules
     *
     * @return {Promise<Array>}
     */
    async getRules() {
        const { rules = [] } = await this.fetchRules('GET');
        return rules;
    }
    /**
     * Adds a rule
     */
    async addRule(rule) {
        await this.fetchRules('POST', { rule });
    }
    /**
     * Removes the rule
     */
    async deleteRule(tag) {
        await this.fetchRules('DELETE', { tag });
    }
    /**
     * Adds a list of rules
     */
    async addRules(rules) {
        await Promise.all(rules.map(rule => (this.addRule(rule))));
    }
    /**
     * Removes all rules
     */
    async deleteRules() {
        const rules = await this.getRules();
        await Promise.all(rules.map(({ tag }) => (this.deleteRule(tag))));
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { started } = this;
        const payload = { started };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

const { MISSING_CAPTCHA_HANDLER, MISSING_TWO_FACTOR_HANDLER } = sharedErrors;
class CallbackService {
    /**
     * Constructor
     */
    constructor(vk) {
        this.captchaHandler = null;
        this.twoFactorHandler = null;
        this.vk = vk;
    }
    /**
     * Checks if there is a captcha handler
     */
    get hasCaptchaHandler() {
        return this.captchaHandler !== null;
    }
    /**
     * Checks if there is a two-factor handler
     */
    get hasTwoFactorHandler() {
        return this.twoFactorHandler !== null;
    }
    /**
     * Processing captcha
     */
    processingCaptcha(payload) {
        return new Promise((resolveProcessing, rejectProcessing) => {
            if (!this.hasCaptchaHandler) {
                rejectProcessing(new VKError({
                    message: 'Missing captcha handler',
                    code: MISSING_CAPTCHA_HANDLER
                }));
                return;
            }
            this.captchaHandler(payload, (key) => (new Promise((resolve, reject) => {
                if (key instanceof Error) {
                    reject(key);
                    rejectProcessing(key);
                    return;
                }
                // @ts-ignore
                resolveProcessing({
                    key,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
    /**
     * Processing two-factor
     */
    processingTwoFactor(payload) {
        return new Promise((resolveProcessing, rejectProcessing) => {
            if (!this.hasTwoFactorHandler) {
                rejectProcessing(new VKError({
                    message: 'Missing two-factor handler',
                    code: MISSING_TWO_FACTOR_HANDLER
                }));
                return;
            }
            this.twoFactorHandler(payload, (code) => (new Promise((resolve, reject) => {
                if (code instanceof Error) {
                    reject(code);
                    rejectProcessing(code);
                    return;
                }
                // @ts-ignore
                resolveProcessing({
                    code,
                    validate: {
                        resolve,
                        reject
                    }
                });
            })));
        });
    }
}

/**
 * Main class
 */
class VK {
    /**
     * Constructor
     */
    constructor(options = {}) {
        this.options = {
            ...defaultOptions,
            agent: new Agent({
                keepAlive: true,
                keepAliveMsecs: 10000
            })
        };
        this.api = new API(this);
        this.auth = new Auth(this);
        this.upload = new Upload(this);
        this.collect = new Collect(this);
        this.updates = new Updates(this);
        this.snippets = new Snippets(this);
        this.streaming = new StreamingAPI(this);
        this.callbackService = new CallbackService(this);
        this.setOptions(options);
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'VK';
    }
    /**
     * Sets options
     */
    setOptions(options) {
        Object.assign(this.options, options);
        return this;
    }
    /**
     * Sets token
     */
    set token(token) {
        this.options.token = token;
    }
    /**
     * Returns token
     */
    get token() {
        return this.options.token;
    }
    /**
     * Sets captcha handler
     *
     * ```ts
     * vk.captchaHandler = (payload, retry) => {...};
     * ```
     */
    set captchaHandler(handler) {
        this.callbackService.captchaHandler = handler;
    }
    /**
     * Sets two-factor handler
     *
     * ```ts
     * vk.twoFactorHandler = (payload, retry) => {...};
     * ```
     */
    set twoFactorHandler(handler) {
        this.callbackService.twoFactorHandler = handler;
    }
    /**
     * Custom inspect object
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [inspect.custom](depth, options) {
        const { name } = this.constructor;
        const { api, updates, streaming } = this;
        const { appId, token, login, phone } = this.options;
        const payload = {
            options: {
                appId,
                login,
                phone,
                token
            },
            api,
            updates,
            streaming
        };
        return `${options.stylize(name, 'special')} ${inspect(payload, options)}`;
    }
}

/**
 * Primary colors used in the text button
 */
// eslint-disable-next-line import/prefer-default-export
var ButtonColor;
(function (ButtonColor) {
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    ButtonColor["SECONDARY"] = "secondary";
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    ButtonColor["PRIMARY"] = "primary";
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    ButtonColor["NEGATIVE"] = "negative";
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    ButtonColor["POSITIVE"] = "positive";
})(ButtonColor || (ButtonColor = {}));

class KeyboardBuilder {
    constructor() {
        /**
         * Does the keyboard close after pressing the button
         */
        this.isOneTime = false;
        /**
         * Rows with all buttons
         */
        this.rows = [];
        /**
         * Current row of buttons
         */
        this.currentRow = [];
    }
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'KeyboardBuilder';
    }
    /**
     * Text button, can be colored
     *
     * ```ts
     * builder.textButton({
     *  label: 'Buy a coffee',
     *  payload: {
     *   command: 'buy',
     *   item: 'coffee'
     *  },
     *  color: Keyboard.POSITIVE_COLOR
     * });
     * ```
     */
    textButton({ label, payload: rawPayload = {}, color = ButtonColor.SECONDARY }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        const payload = JSON.stringify(rawPayload);
        if (payload.length > 255) {
            throw new RangeError('Maximum length of payload 255 characters');
        }
        return this.addButton({
            color,
            action: {
                label,
                payload,
                type: 'text'
            }
        });
    }
    /**
     * User location request button, occupies the entire keyboard width
     *
     * ```ts
     * builder.locationRequestButton({
     *  payload: {
     *   command: 'order_delivery'
     *  }
     * })
     * ```
     */
    locationRequestButton({ payload: rawPayload = {} }) {
        const payload = JSON.stringify(rawPayload);
        if (payload.length > 255) {
            throw new RangeError('Maximum length of payload 255 characters');
        }
        return this.addWideButton({
            action: {
                payload,
                type: 'location'
            }
        });
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     *
     * ```ts
     * builder.payButton({
     *  hash: {
     *   action: 'transfer-to-group',
     *   group_id: 1,
     *   aid: 10
     *  }
     * })
     * ```
     */
    payButton({ hash: rawHash }) {
        const hash = typeof rawHash === 'object'
            ? String(new URLSearchParams(Object.entries(rawHash)))
            : rawHash;
        return this.addWideButton({
            action: {
                hash,
                type: 'vkpay'
            }
        });
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     *
     * ```ts
     * builder.applicationButton({
     *  label: 'LiveWidget',
     *  appId: 6232540,
     *  ownerId: -157525928
     * })
     * ```
     */
    applicationButton({ label, appId, ownerId, hash }) {
        if (label.length > 40) {
            throw new RangeError('Maximum length of label 40 characters');
        }
        return this.addWideButton({
            action: {
                label,
                hash,
                app_id: appId,
                owner_id: ownerId,
                type: 'open_app'
            }
        });
    }
    /**
     * Saves the current row of buttons in the general rows
     */
    row() {
        if (this.currentRow.length === 0) {
            return this;
        }
        if (this.currentRow.length > 4) {
            throw new RangeError('Max count of buttons at columns 4');
        }
        this.rows.push(this.currentRow);
        this.currentRow = [];
        return this;
    }
    /**
     * Sets the keyboard to close after pressing
     *
     * ```ts
     *  builder.oneTime();
     *
     *  builder.oneTime(false);
     * ```
     */
    oneTime(enabled = true) {
        this.isOneTime = enabled;
        return this;
    }
    /**
     * Clones the builder with all the settings
     */
    clone() {
        const builder = new KeyboardBuilder();
        builder.oneTime(this.isOneTime);
        builder.rows = [...this.rows];
        builder.currentRow = [...this.currentRow];
        return builder;
    }
    /**
     * Returns a string to keyboard a VK
     */
    toString() {
        if (this.rows.length > 10) {
            throw new RangeError('Max count of keyboard rows 10');
        }
        return JSON.stringify({
            one_time: this.isOneTime,
            buttons: this.currentRow.length !== 0
                ? [...this.rows, this.currentRow]
                : this.rows
        });
    }
    /**
     * Adds a button to the current row
     */
    addButton(button) {
        this.currentRow.push(button);
        return this;
    }
    /**
     * Adds a wide button to the new row
     */
    addWideButton(button) {
        if (this.currentRow.length !== 0) {
            this.row();
        }
        this.addButton(button);
        return this.row();
    }
}

class Keyboard {
    /**
     * Returns custom tag
     */
    // eslint-disable-next-line class-methods-use-this
    get [Symbol.toStringTag]() {
        return 'Keyboard';
    }
    /**
     * @deprecated Use Keyboard.SECONDARY_COLOR instead
     */
    // eslint-disable-next-line class-methods-use-this
    static get DEFAULT_COLOR() {
        // eslint-disable-next-line no-console
        console.log('Keyboard.DEFAULT_COLOR deprecated, use Keyboard.SECONDARY_COLOR instead');
        return ButtonColor.SECONDARY;
    }
    /**
     * The white button, indicates secondary action
     *
     * Hex color #FFFFFF
     */
    // eslint-disable-next-line class-methods-use-this
    static get SECONDARY_COLOR() {
        return ButtonColor.SECONDARY;
    }
    /**
     * The blue button, indicates the main action
     *
     * Hex color #5181B8
     */
    // eslint-disable-next-line class-methods-use-this
    static get PRIMARY_COLOR() {
        return ButtonColor.PRIMARY;
    }
    /**
     * The red button, indicates a dangerous or a negative action (reject, delete, etc...)
     *
     * Hex color #E64646
     */
    // eslint-disable-next-line class-methods-use-this
    static get NEGATIVE_COLOR() {
        return ButtonColor.NEGATIVE;
    }
    /**
     * The green button, indicates a agree, confirm, ...etc
     *
     * Hex color #4BB34B
     */
    // eslint-disable-next-line class-methods-use-this
    static get POSITIVE_COLOR() {
        return ButtonColor.POSITIVE;
    }
    /**
     * Returns keyboard builder
     */
    static builder() {
        return new KeyboardBuilder();
    }
    /**
     * Assembles a builder of buttons
     */
    static keyboard(rows) {
        const builder = new KeyboardBuilder();
        for (const row of rows) {
            const buttons = Array.isArray(row)
                ? row
                : [row];
            for (const { kind, options } of buttons) {
                if (kind === 'text') {
                    builder.textButton(options);
                    continue;
                }
                if (kind === 'location_request') {
                    builder.locationRequestButton(options);
                    continue;
                }
                if (kind === 'vk_pay') {
                    builder.payButton(options);
                    continue;
                }
                if (kind === 'vk_application') {
                    builder.applicationButton(options);
                    continue;
                }
                throw new TypeError('Unsupported type button');
            }
            builder.row();
        }
        return builder;
    }
    /**
     * Text button, can be colored
     */
    static textButton(options) {
        return { options, kind: 'text' };
    }
    /**
     * User location request button, occupies the entire keyboard width
     */
    static locationRequestButton(options) {
        return { options, kind: 'location_request' };
    }
    /**
     * VK Pay button, occupies the entire keyboard width
     */
    static payButton(options) {
        return { options, kind: 'vk_pay' };
    }
    /**
     * VK Apps button, occupies the entire keyboard width
     */
    static applicationButton(options) {
        return { options, kind: 'vk_application' };
    }
}

export default VK;
export { APIError, Attachment, AudioAttachment, AudioMessageAttachment, AuthError, ButtonColor, CollectError, CommentActionContext, Context, DialogFlagsContext, DocumentAttachment, ExecuteError, ExternalAttachment, GiftAttachment, GraffitiAttachment, GroupMemberContext, GroupUpdateContext, GroupUserContext, Keyboard, KeyboardBuilder, LinkAttachment, MarketAlbumAttachment, MarketAttachment, MessageAllowContext, MessageContext, MessageFlagsContext, NewAttachmentsContext, PhotoAttachment, PollAttachment, ReadMessagesContext, RemovedMessagesContext, Request, SnippetsError, StickerAttachment, StreamingContext, StreamingRuleError, TypingContext, UpdatesError, UploadError, VoteContext$1 as UserOnlineContext, VK, VKAppPayloadContext, VKError, VKPayTransactionContext, VideoAttachment, VoteContext, WallAttachment, WallPostContext, WallReplyAttachment, apiErrors, attachmentTypes, authErrors, captchaTypes, collectErrors, messageSources, resourceTypes, sharedErrors, snippetsErrors, updatesErrors, uploadErrors };
